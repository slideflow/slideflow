


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>slideflow.slide.wsi &mdash; slideflow 3.0.0 documentation</title>















  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="../../../../genindex/" />
    <link rel="search" title="Search" href="../../../../search/" />




  <script src="../../../../_static/js/modernizr.min.js"></script>

  <!-- Preload the theme fonts -->

<link rel="preload" href="../../../../_static/fonts/IBMPlexSans/IBMPlexSans-Light.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexSans/IBMPlexSans-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexMono/IBMPlexMono-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexSans/IBMPlexSans-Medium.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexSans/IBMPlexSans-MediumItalic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="../../../../_static/fonts/IBMPlexMono/IBMPlexMono-SemiBold.woff2" as="font" type="font/woff2" crossorigin="anonymous">

<!-- Preload the katex fonts -->

<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Math-Italic.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Main-Bold.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size1-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size4-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size2-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Size3-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/fonts/KaTeX_Caligraphic-Regular.woff2" as="font" type="font/woff2" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous">
  <script defer data-domain="slideflow.dev" src="https://plausible.io/js/script.js"></script>
</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://slideflow.dev" aria-label="Slideflow"></a>

      <div class="main-menu">
        <ul>
          <li class="active">
            <a href="https://slideflow.dev">Docs</a>
          </li>

          <li>
            <a href="https://slideflow.dev/tutorial1/">Tutorials</a>
          </li>

          <li>
            <a href="https://github.com/slideflow/slideflow">GitHub</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

<body class="pytorch-body">





    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">





                <div class="version">
                  3.0
                </div>









<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search/" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


          </div>







              <p class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation/">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../overview/">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quickstart/">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../project_setup/">Setting up a Project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../datasets_and_val/">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../slide_processing/">Slide Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../training/">Training</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../evaluation/">Evaluation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../posthoc/">Layer Activations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../uq/">Uncertainty Quantification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../features/">Generating Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mil/">Multiple-Instance Learning (MIL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../ssl/">Self-Supervised Learning (SSL)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../stylegan/">Generative Networks (GANs)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../saliency/">Saliency Maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../segmentation/">Tissue Segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cellseg/">Cell Segmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../custom_loops/">Custom Training Loops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../studio/">Slideflow Studio: Live Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../troubleshooting/">Troubleshooting</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tfrecords/">TFRecords: Reading and Writing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dataloaders/">Dataloaders: Sampling and Augmentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../custom_extractors/">Custom Feature Extractors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tile_labels/">Strong Supervision with Tile Labels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../plugins/">Creating a Slideflow Plugin</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../slideflow/">slideflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../project/">slideflow.Project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dataset/">slideflow.Dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../dataset_features/">slideflow.DatasetFeatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../heatmap/">slideflow.Heatmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_params/">slideflow.ModelParams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mosaic/">slideflow.Mosaic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../slidemap/">slideflow.SlideMap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../biscuit/">slideflow.biscuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../slideflow_cellseg/">slideflow.cellseg</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io/">slideflow.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io_tensorflow/">slideflow.io.tensorflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../io_torch/">slideflow.io.torch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gan/">slideflow.gan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../grad/">slideflow.grad</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../mil_module/">slideflow.mil</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model/">slideflow.model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_tensorflow/">slideflow.model.tensorflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../model_torch/">slideflow.model.torch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../norm/">slideflow.norm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../simclr/">slideflow.simclr</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../slide/">slideflow.slide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../slide_qc/">slideflow.slide.qc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../stats/">slideflow.stats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../util/">slideflow.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../studio_module/">slideflow.studio</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial1/">Tutorial 1: Model training (simple)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial2/">Tutorial 2: Model training (advanced)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial3/">Tutorial 3: Using a custom architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial4/">Tutorial 4: Model evaluation &amp; heatmaps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial5/">Tutorial 5: Creating a mosaic map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial6/">Tutorial 6: Custom slide filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial7/">Tutorial 7: Training with custom augmentations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial8/">Tutorial 8: Multiple-Instance Learning</a></li>
</ul>



        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">

      <li>
        <a href="../../../../">

            Docs

        </a> &gt;
      </li>


          <li><a href="../../../">Module code</a> &gt;</li>

      <li>slideflow.slide.wsi</li>


      <li class="pytorch-breadcrumbs-aside">

      </li>

  </ul>


</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">



          <div class="rst-content">

            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">

  <h1>Source code for slideflow.slide.wsi</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;This module includes tools to convolutionally section whole slide images</span>
<span class="sd">into tiles. These tessellated tiles can be exported as PNG or JPG as raw</span>
<span class="sd">images or stored in the binary format TFRecords, with or without augmentation.&#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>


<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">rasterio.features</span>
<span class="kn">import</span> <span class="nn">shapely.affinity</span> <span class="k">as</span> <span class="nn">sa</span>
<span class="kn">import</span> <span class="nn">skimage</span>
<span class="kn">import</span> <span class="nn">skimage.filters</span>
<span class="kn">from</span> <span class="nn">shapely</span> <span class="kn">import</span> <span class="n">__version__</span> <span class="k">as</span> <span class="n">shapely_version</span>
<span class="kn">from</span> <span class="nn">shapely.errors</span> <span class="kn">import</span> <span class="n">ShapelyDeprecationWarning</span>
<span class="kn">from</span> <span class="nn">packaging</span> <span class="kn">import</span> <span class="n">version</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span><span class="p">,</span> <span class="n">ImageDraw</span>
<span class="kn">from</span> <span class="nn">rich.progress</span> <span class="kn">import</span> <span class="n">Progress</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">img_as_ubyte</span>
<span class="kn">from</span> <span class="nn">slideflow</span> <span class="kn">import</span> <span class="n">errors</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">exists</span><span class="p">,</span> <span class="n">join</span><span class="p">,</span> <span class="n">abspath</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">SimpleNamespace</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Sequence</span>

<span class="kn">import</span> <span class="nn">slideflow</span> <span class="k">as</span> <span class="nn">sf</span>
<span class="kn">import</span> <span class="nn">slideflow.slide.qc</span>
<span class="kn">from</span> <span class="nn">slideflow.util</span> <span class="kn">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">path_to_name</span>  <span class="c1"># noqa F401</span>
<span class="kn">from</span> <span class="nn">.report</span> <span class="kn">import</span> <span class="n">SlideReport</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.backends</span> <span class="kn">import</span> <span class="n">tile_worker</span><span class="p">,</span> <span class="n">backend_formats</span><span class="p">,</span> <span class="n">wsi_reader</span>


<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">Image</span><span class="o">.</span><span class="n">DecompressionBombWarning</span><span class="p">)</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">ShapelyDeprecationWarning</span><span class="p">)</span>
<span class="n">Image</span><span class="o">.</span><span class="n">MAX_IMAGE_PIXELS</span> <span class="o">=</span> <span class="mi">100000000000</span>

<span class="c1"># -----------------------------------------------------------------------</span>

<div class="viewcode-block" id="WSI"><a class="viewcode-back" href="../../../../slide/#slideflow.slide.WSI">[docs]</a><span class="k">class</span> <span class="nc">WSI</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Loads a slide and its annotated region of interest (ROI).&#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">tile_px</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">tile_um</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">stride_div</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">enable_downsample</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">roi_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rois</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">roi_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
        <span class="n">roi_filter_method</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;center&#39;</span><span class="p">,</span>
        <span class="n">origin</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">pb</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Progress</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">use_edge_tiles</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">mpp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">simplify_roi_tolerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">artifact_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">reader_kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Loads slide and ROI(s).</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str): Path to slide.</span>
<span class="sd">            tile_px (int): Size of tiles to extract, in pixels.</span>
<span class="sd">            tile_um (int or str): Size of tiles to extract, in microns (int) or</span>
<span class="sd">                magnification (str, e.g. &quot;20x&quot;).</span>
<span class="sd">            stride_div (int, optional): Stride divisor for tile extraction</span>
<span class="sd">                (1 = no tile overlap; 2 = 50% overlap, etc). Defaults to 1.</span>
<span class="sd">            enable_downsample (bool, optional): Allow use of downsampled</span>
<span class="sd">                intermediate layers in the slide image pyramid, which greatly</span>
<span class="sd">                improves tile extraction speed. May result in artifacts for</span>
<span class="sd">                slides with incompletely generated intermediates pyramids.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            roi_dir (str, optional): Directory in which to search for ROI CSV</span>
<span class="sd">                files. Defaults to None.</span>
<span class="sd">            rois (list(str)): Alternatively, a list of ROI paths can be</span>
<span class="sd">                explicitly provided. Defaults to None.</span>
<span class="sd">            roi_method (str): Either &#39;inside&#39;, &#39;outside&#39;, &#39;auto&#39;, or &#39;ignore&#39;.</span>
<span class="sd">                Determines how ROIs are used to extract tiles.</span>
<span class="sd">                If &#39;inside&#39; or &#39;outside&#39;, will extract tiles in/out of an ROI,</span>
<span class="sd">                and raise errors.MissingROIError if an ROI is not available.</span>
<span class="sd">                If &#39;auto&#39;, will extract tiles inside an ROI if available,</span>
<span class="sd">                and across the whole-slide if no ROI is found.</span>
<span class="sd">                If &#39;ignore&#39;, will extract tiles across the whole-slide</span>
<span class="sd">                regardless of whether an ROI is available.</span>
<span class="sd">                Defaults to &#39;auto&#39;.</span>
<span class="sd">            roi_filter_method (str or float): Method of filtering tiles with</span>
<span class="sd">                ROIs. Either &#39;center&#39; or float (0-1). If &#39;center&#39;, tiles are</span>
<span class="sd">                filtered with ROIs based on the center of the tile. If float,</span>
<span class="sd">                tiles are filtered based on the proportion of the tile inside</span>
<span class="sd">                the ROI, and ``roi_filter_method`` is interpreted as a</span>
<span class="sd">                threshold. If the proportion of a tile inside the ROI is</span>
<span class="sd">                greater than this number, the tile is included. For example,</span>
<span class="sd">                if ``roi_filter_method=0.7``, a tile that is 80% inside of an</span>
<span class="sd">                ROI will be included, and a tile that is 50% inside of an ROI</span>
<span class="sd">                will be excluded. Defaults to &#39;center&#39;.</span>
<span class="sd">            origin (str or tuple(int, int)): Offset the starting grid (x, y).</span>
<span class="sd">                Either a tuple of ints or &#39;random&#39;. Defaults to (0, 0).</span>
<span class="sd">            pb (:class:`Progress`, optional): Multiprocessing</span>
<span class="sd">                capable Progress instance; will update progress bar during</span>
<span class="sd">                tile extraction if provided.</span>
<span class="sd">            verbose (bool, optional): Controls verbosity of output. If False,</span>
<span class="sd">                suppresses warnings about slide skipping when ROIs are missing.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            mpp (float, optional): Override the microns-per-pixel value for</span>
<span class="sd">                the slide. Defaults to None (auto-detects).</span>
<span class="sd">            ignore_missing_mpp (bool, optional): If a slide does not have</span>
<span class="sd">                microns-per-pixel (MPP) information stored in EXIF data</span>
<span class="sd">                (key 65326), set the MPP to a default value</span>
<span class="sd">                (``sf.slide.DEFAULG_JPG_MPP``). If False and MPP data is</span>
<span class="sd">                missing, raises ``sf.errors.SlideMissingMPPError``.</span>
<span class="sd">            use_bounds (bool): If True, use the slide bounds to determine</span>
<span class="sd">                the slide dimensions. This will crop out unscanned white space.</span>
<span class="sd">                If a tuple of int, interprets the bounds as ``(top_left_x,</span>
<span class="sd">                top_left_y, width, height)``. If False, use the full slide</span>
<span class="sd">                dimensions. **Only available when using Libvips**</span>
<span class="sd">                (``SF_SLIDE_BACKEND=libvips``). Defaults to False.</span>
<span class="sd">            transforms (list(int), optional): List of transforms to apply to</span>
<span class="sd">                the slide before establishing coordinate grid. Options include</span>
<span class="sd">                any combination of ``ROTATE_90_CLOCKWISE``,</span>
<span class="sd">                ``ROTATE_180_CLOCKWISE``, ``ROTATE_270_CLOCKWISE``,</span>
<span class="sd">                ``FLIP_HORIZONTAL``, and ``FLIP_VERTICAL``. **Only available</span>
<span class="sd">                when using Libvips** (``SF_SLIDE_BACKEND=libvips``).</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            artifact_labels (list(str), optional): List of ROI issue labels</span>
<span class="sd">                to treat as artifacts. Whenever this is not None, all the ROIs with</span>
<span class="sd">                referred label will be inverted with ROI.invert().</span>
<span class="sd">                Defaults to an empty list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize calculated variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">path_to_name</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shortname</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">_shortname</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span> <span class="o">=</span> <span class="n">tile_px</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enable_downsample</span> <span class="o">=</span> <span class="n">enable_downsample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thumb_image</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[Image.Image]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride_div</span> <span class="o">=</span> <span class="n">stride_div</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filetype</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">path_to_ext</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blur_burden</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[float]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[str]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extracted_x_size</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># type: int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extracted_y_size</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># type: int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimated_num_tiles</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># type: int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rois</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[ROI]  # List of individual ROI annotations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">=</span> <span class="n">roi_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roi_grid</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[np.ndarray]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roi_filter_method</span> <span class="o">=</span> <span class="n">roi_filter_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qc_masks</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List[QCMask]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Optional[Alignment]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segmentation</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_edge_tiles</span> <span class="o">=</span> <span class="n">use_edge_tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__slide</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mpp_override</span> <span class="o">=</span> <span class="n">mpp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reader_kwargs</span> <span class="o">=</span> <span class="n">reader_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">artifact_labels</span> <span class="o">=</span> <span class="n">artifact_labels</span> <span class="c1"># type: Optional[List[str]]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">artifact_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">artifact_labels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">origin</span> <span class="o">!=</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unrecognized value for argument &#39;origin&#39;: </span><span class="si">{}</span><span class="s2"> .&quot;</span>
                <span class="s2">&quot;Expected either &#39;random&#39; or a tuple of ints.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If &#39;origin&#39; is a tuple, it must be of length 2.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">roi_filter_method</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
           <span class="ow">and</span> <span class="n">roi_filter_method</span> <span class="o">!=</span> <span class="s1">&#39;center&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Unrecognized value for argument &#39;roi_filter_method&#39;: </span><span class="si">{}</span><span class="s2"> .&quot;</span>
                <span class="s2">&quot;Expected either float or &#39;center&#39;.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">roi_filter_method</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">roi_filter_method</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span>
           <span class="ow">and</span> <span class="p">(</span><span class="n">roi_filter_method</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">roi_filter_method</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If &#39;roi_filter_method&#39; is a float, it must be between 0-1.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">rois</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">rois</span> <span class="o">=</span> <span class="p">[</span><span class="n">rois</span><span class="p">]</span>

        <span class="c1"># Initiate supported slide reader</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">SlideNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find slide </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filetype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">SUPPORTED_FORMATS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">SlideLoadError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: unsupported filetype &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filetype</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filetype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">backend_formats</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">IncompatibleBackendError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: filetype &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filetype</span><span class="si">}</span><span class="s2">&#39; is not supported &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;by the current backend, </span><span class="si">{</span><span class="n">sf</span><span class="o">.</span><span class="n">slide_backend</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Collect basic slide information</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">has_mpp</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">SlideMissingMPPError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Slide </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2"> missing MPP (</span><span class="si">{</span><span class="n">OPS_MPP_X</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">mpp</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">SlideMissingMPPError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unable to parse MPP for slide </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">OPS_MPP_X</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Error raised: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Configure downsample information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_configure_downsample</span><span class="p">(</span><span class="n">tile_um</span><span class="p">)</span>

        <span class="c1"># Look in ROI directory if available</span>
        <span class="k">if</span> <span class="n">roi_dir</span> <span class="ow">and</span> <span class="n">exists</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">roi_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.csv&quot;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_csv_roi</span><span class="p">(</span>
                <span class="n">join</span><span class="p">(</span><span class="n">roi_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;.csv&quot;</span><span class="p">),</span>
                <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">simplify_tolerance</span><span class="o">=</span><span class="n">simplify_roi_tolerance</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">rois</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">path_to_name</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rois</span><span class="p">]:</span>
            <span class="n">matching_rois</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">rp</span> <span class="ow">in</span> <span class="n">rois</span><span class="p">:</span>
                <span class="n">rn</span> <span class="o">=</span> <span class="n">path_to_name</span><span class="p">(</span><span class="n">rp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">rn</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">matching_rois</span> <span class="o">+=</span> <span class="p">[</span><span class="n">rp</span><span class="p">]</span>
            <span class="n">matching</span> <span class="o">=</span> <span class="n">matching_rois</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matching_rois</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Multiple ROIs found for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">; using </span><span class="si">{</span><span class="n">matching</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_csv_roi</span><span class="p">(</span>
                <span class="n">matching</span><span class="p">,</span>
                <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">simplify_tolerance</span><span class="o">=</span><span class="n">simplify_roi_tolerance</span>
            <span class="p">)</span>

        <span class="c1"># Handle missing ROIs</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">)</span>
           <span class="ow">and</span> <span class="n">roi_method</span> <span class="o">!=</span> <span class="s1">&#39;ignore&#39;</span>
           <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rois</span> <span class="ow">or</span> <span class="n">roi_dir</span><span class="p">)):</span>
            <span class="c1"># No ROIs found because the user did not provide rois or roi_dir,</span>
            <span class="c1"># but the roi_method is not set to &#39;ignore&#39;,</span>
            <span class="c1"># indicating that this may be user error.</span>
            <span class="n">warn_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;No ROIs provided for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rois</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">roi_dir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">warn_msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">warn_msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">)</span> <span class="ow">and</span> <span class="n">roi_method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;inside&#39;</span><span class="p">,</span> <span class="s1">&#39;outside&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">MissingROIError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Slide [green]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">[/] missing ROI.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">):</span>
            <span class="n">info_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;No ROI for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, using whole slide.&quot;</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">roi_method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">info_msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">info_msg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">)</span> <span class="ow">and</span> <span class="n">roi_method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Slide </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: extracting tiles from inside ROI.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">=</span> <span class="s1">&#39;inside&#39;</span>

        <span class="c1"># Build coordinate grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_rois</span><span class="p">()</span>

        <span class="c1"># Summarize slide information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log_slide_summary</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">base</span> <span class="o">=</span> <span class="s2">&quot;WSI(</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">base</span> <span class="o">+=</span> <span class="s2">&quot;  path = </span><span class="si">{!r}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">+=</span> <span class="s2">&quot;  tile_px = </span><span class="si">{!r}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">+=</span> <span class="s2">&quot;  tile_um = </span><span class="si">{!r}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_um</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">+=</span> <span class="s2">&quot;  stride_div = </span><span class="si">{!r}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stride_div</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">+=</span> <span class="s2">&quot;  enable_downsample = </span><span class="si">{!r}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">enable_downsample</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">+=</span> <span class="s2">&quot;  roi_method = </span><span class="si">{!r}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">+=</span> <span class="s2">&quot;)&quot;</span>
        <span class="k">return</span> <span class="n">base</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a tile at the given index.</span>

<span class="sd">        Args:</span>
<span class="sd">            index (tuple): (x, y) grid coordinates of tile to extract.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[numpy.ndarray]: Image tile, or None if tile is filtered.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Verify indices are valid</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
           <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Must supply exactly two indices: (x, y)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;index </span><span class="si">{}</span><span class="s2"> is out of bounds for axis 0 with size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;index </span><span class="si">{}</span><span class="s2"> is out of bounds for axis 0 with size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Find the corresponding coordinate given the provided indices.</span>
        <span class="n">coord_idx</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_idx</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">coord_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># Check if indices correspond to a tile that is filtered out,</span>
        <span class="c1"># either by ROI or QC. If so, return None.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Extract the numpy image at this grid location.</span>
        <span class="n">image_dict</span> <span class="o">=</span> <span class="n">tile_worker</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span><span class="p">),</span>
            <span class="n">SimpleNamespace</span><span class="p">(</span>
                <span class="n">full_extract_px</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="p">,</span>
                <span class="n">mpp_override</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mpp_override</span><span class="p">,</span>
                <span class="n">reader_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_reader_kwargs</span><span class="p">,</span>
                <span class="n">grid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
                <span class="n">downsample_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample_level</span><span class="p">,</span>
                <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                <span class="n">extract_px</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_px</span><span class="p">,</span>
                <span class="n">tile_px</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span>
                <span class="n">full_stride</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">full_stride</span><span class="p">,</span>
                <span class="n">normalizer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">whitespace_fraction</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">whitespace_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">grayspace_fraction</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">grayspace_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">img_format</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span>
                <span class="n">yolo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">draw_roi</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">dry_run</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">has_segmentation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Remove the unpicklable entries.</span>
        <span class="k">if</span> <span class="s1">&#39;__slide&#39;</span> <span class="ow">in</span> <span class="n">state</span><span class="p">:</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;__slide&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;_WSI__slide&#39;</span> <span class="ow">in</span> <span class="n">state</span><span class="p">:</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_WSI__slide&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;pb&#39;</span> <span class="ow">in</span> <span class="n">state</span><span class="p">:</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;pb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rasterize_rois_to_grid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rois</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ROI&quot;</span><span class="p">],</span>
        <span class="n">x_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">y_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">xfact</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span>
        <span class="n">yfact</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">grid_scale</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">invert</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rasterize ROIs to the size of the tile extraction grid.</span>

<span class="sd">        Args:</span>
<span class="sd">            rois (List[ROI]): ROIs to rasterize.</span>
<span class="sd">            x_offset (float): Offset to align the ROI polygons with the image tile grid.</span>
<span class="sd">            y_offset (float): Offset to align the ROI polygons with the image tile grid.</span>
<span class="sd">            xfact (float): Scaling factor along x dimension.</span>
<span class="sd">            yfact (float): Scaling factor along y dimension.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            grid_scale (int): Scaling factor for the grid. Defaults to 1.</span>
<span class="sd">            invert (bool): Whether to invert the ROI. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Optional[np.ndarray]: Rasterized ROIs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_get_poly</span><span class="p">(</span><span class="n">_roi</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_roi</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span><span class="o">.</span><span class="n">poly</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_roi</span><span class="o">.</span><span class="n">poly</span>

        <span class="c1"># Convert ROIs to polygons.</span>
        <span class="n">polys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_get_poly</span><span class="p">,</span> <span class="n">rois</span><span class="p">))</span>

        <span class="c1"># Translate and scale.</span>
        <span class="k">if</span> <span class="n">x_offset</span> <span class="ow">or</span> <span class="n">y_offset</span><span class="p">:</span>
            <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">sa</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">x_offset</span><span class="p">,</span> <span class="n">y_offset</span><span class="p">)</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xfact</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">yfact</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">polys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_polys</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="n">xfact</span> <span class="o">*</span> <span class="n">grid_scale</span><span class="p">,</span> <span class="n">yfact</span> <span class="o">*</span> <span class="n">grid_scale</span><span class="p">)</span>

        <span class="c1"># Rasterize polygons to the size of the tile extraction grid.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rasterize_polys</span><span class="p">(</span>
            <span class="n">polys</span><span class="p">,</span>
            <span class="n">grid_scale</span><span class="o">=</span><span class="n">grid_scale</span><span class="p">,</span>
            <span class="n">intersection</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;min&#39;</span> <span class="k">if</span> <span class="n">invert</span> <span class="k">else</span> <span class="s1">&#39;max&#39;</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rasterize_polys</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">polys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;sg.Polygon&quot;</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">grid_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">intersection</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;max&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rasterize polygons to the size of the tile extraction grid.</span>

<span class="sd">        Args:</span>
<span class="sd">            polys (List[sg.Polygon]): Polygons to rasterize.</span>

<span class="sd">        Keyword args:</span>
<span class="sd">            scale (float): Scaling factor for the grid.</span>
<span class="sd">                Defaults to 1.</span>
<span class="sd">            intersection (str): Method for combining multiple polygons.</span>
<span class="sd">                Either &#39;max&#39; or &#39;min&#39;. &#39;max&#39; yields the union of the polygons,</span>
<span class="sd">                &#39;min&#39; yields the intersection. Defaults to &#39;max&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Rasterized polygons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Rasterize polygons for ROIs individually, to keep track of</span>
        <span class="c1"># which ROI each tile belongs to, then merge.</span>
        <span class="n">roi_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span>
            <span class="n">rasterio</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span>
                <span class="p">[</span><span class="n">poly</span><span class="p">],</span>
                <span class="n">out_shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">grid_scale</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">grid_scale</span><span class="p">),</span>
                <span class="n">all_touched</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>
        <span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">intersection</span> <span class="o">==</span> <span class="s1">&#39;max&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">roi_grid</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">elif</span> <span class="n">intersection</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">roi_grid</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unrecognized value for &#39;intersection&#39;: </span><span class="si">{</span><span class="n">intersection</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_scale_polys</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">polys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;sg.Polyon&quot;</span><span class="p">],</span>
        <span class="n">xfact</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">yfact</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scale polygons.</span>

<span class="sd">        Args:</span>
<span class="sd">            polys (List[sg.Polygon]): Polygons to scale.</span>
<span class="sd">            xfact (float): Scaling factor along x dimension.</span>
<span class="sd">            yfact (float): Scaling factor along y dimension.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[sg.Polygon]: Scaled polygons.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">sa</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">xfact</span><span class="o">=</span><span class="n">xfact</span><span class="p">,</span> <span class="n">yfact</span><span class="o">=</span><span class="n">yfact</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">polys</span>
        <span class="p">]</span>

    <span class="k">def</span> <span class="nf">_build_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up coordinate grid for image tiles.</span>

<span class="sd">        The coordinate grid, stored in ``self.coord``, is a list of lists,</span>
<span class="sd">        where each sublist contains the following information:</span>

<span class="sd">        - 0: **x**: x-coordinate of the top-left corner of the tile.</span>
<span class="sd">        - 1: **y**: y-coordinate of the top-left corner of the tile.</span>
<span class="sd">        - 2: **grid_x**: x-coordinate of the tile in self.grid.</span>
<span class="sd">        - 3: **grid_y**: y-coordinate of the tile in self.grid.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># First, remove any existing ROI QC Masks, as these will be recalculated</span>
        <span class="c1"># when the coordinate grid is rebuilt.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_roi_qc</span><span class="p">()</span>

        <span class="c1"># Calculate window sizes, strides, and coordinates for windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extracted_x_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extracted_y_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span>

        <span class="c1"># Randomize origin, if desired</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="n">start_x</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_stride</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">start_y</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_stride</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="n">start_x</span><span class="p">,</span> <span class="n">start_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Slide origin: (</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start_x</span><span class="p">,</span> <span class="n">start_y</span><span class="p">))</span>

        <span class="c1"># Coordinates must be in level 0 (full) format</span>
        <span class="c1"># for the read_region function.</span>
        <span class="c1"># Coordinates correspond to top-left corner of the tile.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: Union[List, np.ndarray]</span>
        <span class="n">edge_buffer</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_edge_tiles</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span>
        <span class="n">y_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="n">start_y</span><span class="p">,</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">edge_buffer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_stride</span>
        <span class="p">)</span>
        <span class="n">x_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="n">start_x</span><span class="p">,</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">edge_buffer</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_stride</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x_range</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_range</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># For any indexes in y_range or x_range corresponding to a negative value,</span>
        <span class="c1"># set the corresponding index in self.grid to False.</span>
        <span class="c1"># This may occur after slide alignment.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">x_range</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">y_range</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># ROI filtering</span>
        <span class="n">roi_by_center</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_filter_method</span> <span class="o">==</span> <span class="s1">&#39;center&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rois</span><span class="p">():</span>

            <span class="c1"># Full extraction size and stride</span>
            <span class="n">full_extract</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_um</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span>
            <span class="n">stride</span> <span class="o">=</span> <span class="n">full_extract</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_div</span>

            <span class="c1"># Coverage size of the extracted image tiles</span>
            <span class="n">xtrim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">stride</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>  <span class="c1"># type: ignore</span>
            <span class="n">ytrim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">stride</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># type: ignore</span>

            <span class="c1"># Degree to which the ROIs will need to be scaled</span>
            <span class="c1"># to match the extracted image tile grid</span>
            <span class="n">xfact</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">xtrim</span>
            <span class="n">yfact</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">ytrim</span>

            <span class="c1"># Offset to align the ROI polygons with the image tile grid</span>
            <span class="n">x_offset</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">full_extract</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">stride</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">y_offset</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">full_extract</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">stride</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># Separate ROIs by whether they are artifact or not</span>
            <span class="n">rois</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rois</span><span class="p">(</span><span class="n">ignore_artifact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">artifacts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_artifacts</span><span class="p">()</span>

            <span class="c1"># Prepare ROI rasterization arguments</span>
            <span class="n">rasterize_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">x_offset</span><span class="o">=</span><span class="n">x_offset</span><span class="p">,</span>
                <span class="n">y_offset</span><span class="o">=</span><span class="n">y_offset</span><span class="p">,</span>
                <span class="n">xfact</span><span class="o">=</span><span class="n">xfact</span><span class="p">,</span>
                <span class="n">yfact</span><span class="o">=</span><span class="n">yfact</span><span class="p">,</span>
                <span class="n">grid_scale</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">roi_by_center</span> <span class="k">else</span> <span class="mi">50</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="c1"># Rasterize ROIs to the grid</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rois</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">roi_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rasterize_rois_to_grid</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="o">**</span><span class="n">rasterize_kw</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">roi_grid</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># If there are artifact ROIs, rasterize these to the grid</span>
            <span class="c1"># and subtract them from the main ROI grid.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">artifacts</span><span class="p">):</span>
                <span class="n">roi_grid_issues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rasterize_rois_to_grid</span><span class="p">(</span><span class="n">artifacts</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">rasterize_kw</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">roi_grid</span> <span class="o">=</span> <span class="n">roi_grid_issues</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">roi_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">roi_grid_issues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_grid</span><span class="p">)</span>

            <span class="c1"># Create a merged boolean mask.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roi_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_grid</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roi_mask</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">yi</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">y_range</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x_range</span><span class="p">):</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                <span class="c1"># Skip the slide if the coordinate has a negative value.</span>
                <span class="c1"># This may happen after slide alignment.</span>
                <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">])</span>

                <span class="c1"># ROI filtering</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rois</span><span class="p">()</span> <span class="ow">and</span> <span class="n">roi_by_center</span><span class="p">:</span>
                    <span class="n">point_in_roi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_mask</span><span class="p">[</span><span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span>
                    <span class="c1"># If the extraction method is &#39;inside&#39;,</span>
                    <span class="c1"># skip the tile if it&#39;s not in an ROI</span>
                    <span class="k">if</span> <span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;inside&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">point_in_roi</span><span class="p">)</span>
                       <span class="ow">or</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">==</span> <span class="s1">&#39;outside&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">point_in_roi</span><span class="p">)):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># If roi_filter_method is a float, then perform tile selection</span>
        <span class="c1"># based on what proportion of the tile is in an ROI,</span>
        <span class="c1"># rather than choosing a tile by centroid (roi_filter_method=&#39;center&#39;)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">!=</span> <span class="s1">&#39;ignore&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rois</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">roi_by_center</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_qc_mask</span><span class="p">(</span>
                <span class="p">(</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_mask</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">==</span> <span class="s1">&#39;inside&#39;</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_mask</span><span class="p">),</span>
                <span class="n">filter_threshold</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_filter_method</span><span class="p">),</span>  <span class="c1"># type: ignore</span>
                <span class="n">is_roi</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">)</span>
        <span class="c1"># Handle the case where there is only one tile</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimated_num_tiles</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Set up coordinate grid, shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_configure_downsample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tile_um</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">enable_downsample</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Configure downsample level for tile extraction.</span>

<span class="sd">        Args:</span>
<span class="sd">            tile_um (int or str): Size of tiles to extract, in microns (int) or</span>
<span class="sd">                magnification (str, e.g. &quot;20x&quot;).</span>
<span class="sd">            enable_downsample (bool, optional): Allow use of downsampled</span>
<span class="sd">                intermediate layers in the slide image pyramid, which greatly</span>
<span class="sd">                improves tile extraction speed. May result in artifacts for</span>
<span class="sd">                slides with incompletely generated intermediates pyramids.</span>
<span class="sd">                Defaults to True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate downsample by magnification</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tile_um</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">assert_is_mag</span><span class="p">(</span><span class="n">tile_um</span><span class="p">)</span>
            <span class="n">_mag_lvl</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">level_downsamples</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">)</span>
            <span class="n">mag_levels</span> <span class="o">=</span> <span class="n">_mag_lvl</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">closest_mag</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="n">mag_levels</span><span class="p">,</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">to_mag</span><span class="p">(</span><span class="n">tile_um</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">closest_mag</span> <span class="o">-</span> <span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">to_mag</span><span class="p">(</span><span class="n">tile_um</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">SlideLoadError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: Could not find magnification level &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;matching </span><span class="si">{</span><span class="n">tile_um</span><span class="si">}</span><span class="s2"> (closest: </span><span class="si">{</span><span class="n">closest_mag</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
            <span class="n">ds_level</span> <span class="o">=</span> <span class="n">mag_levels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">closest_mag</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">enable_downsample</span> <span class="ow">and</span> <span class="n">ds_level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to use magnification </span><span class="si">{</span><span class="n">tile_um</span><span class="si">}</span><span class="s2"> with &quot;</span>
                                 <span class="s2">&quot;enable_downsample=False&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">downsample_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">level_downsamples</span><span class="p">[</span><span class="n">ds_level</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extract_px</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_um</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using magnification </span><span class="si">{</span><span class="n">closest_mag</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">x (level=&quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ds_level</span><span class="si">}</span><span class="s2">, tile_um=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_um</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate downsample level by tile micron size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tile_um</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_um</span> <span class="o">=</span> <span class="n">tile_um</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tile_um</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span>
            <span class="k">if</span> <span class="n">enable_downsample</span><span class="p">:</span>
                <span class="n">ds_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">best_level_for_downsample</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ds_level</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">downsample_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">level_downsamples</span><span class="p">[</span><span class="n">ds_level</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extract_px</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample_factor</span>

        <span class="c1"># Calculate filter dimensions (low magnification for filtering out</span>
        <span class="c1"># white background and performing edge detection)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">level_dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_magnification</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filter_dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                    <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_magnification</span><span class="p">)</span>

        <span class="c1"># Calculate shape and stride</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">downsample_level</span> <span class="o">=</span> <span class="n">ds_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">downsample_dimensions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">level_dimensions</span><span class="p">[</span><span class="n">ds_level</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_px</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_div</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_stride</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">stride_div</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_log_slide_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log slide information (MPP, ROIs, grid shape, number of tiles).&quot;&quot;&quot;</span>
        <span class="n">mpp_roi_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="si">}</span><span class="s1"> um/px | </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">)</span><span class="si">}</span><span class="s1"> ROI(s)&#39;</span>
        <span class="n">size_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> x </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shortname</span><span class="si">}</span><span class="s2">: Slide info: </span><span class="si">{</span><span class="n">mpp_roi_msg</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">size_msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">grid_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shortname</span><span class="si">}</span><span class="s2">: Grid shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> &quot;</span>
        <span class="n">grid_msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;| Tiles to extract: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">estimated_num_tiles</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">grid_msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_log_tile_extraction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log tile extraction parameters.&quot;&quot;&quot;</span>
        <span class="n">lead_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Extracting </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_um</span><span class="si">}</span><span class="s1">um tiles&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_px</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">:</span>
            <span class="n">resize_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(resizing </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_px</span><span class="si">}</span><span class="s1">px -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="si">}</span><span class="s1">px)&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resize_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_px</span><span class="si">}</span><span class="s1">px, not resizing)&#39;</span>
        <span class="n">stride_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;stride: </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stride</span><span class="p">)</span><span class="si">}</span><span class="s1">px&#39;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shortname</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">lead_msg</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">resize_msg</span><span class="si">}</span><span class="s2">; </span><span class="si">{</span><span class="n">stride_msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_px</span><span class="p">:</span>
            <span class="n">ups_msg</span> <span class="o">=</span> <span class="s1">&#39;Tiles will be up-scaled with bilinear interpolation&#39;</span>
            <span class="n">ups_amnt</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">extract_px</span><span class="si">}</span><span class="s1">px -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="si">}</span><span class="s1">px)&#39;</span>
            <span class="n">warn</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;[red]&#39;!WARN!&#39;[/]&quot;</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shortname</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">warn</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">ups_msg</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">ups_amnt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dimensions of highest-magnification level (width, height)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">levels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of dict, with metadata for each level.</span>

<span class="sd">        Each dict has the keys &#39;dimensions&#39;, &#39;downsample&#39;, &#39;height&#39;, and &#39;weight&#39;.</span>

<span class="sd">        - **&#39;dimensions&#39;**: (height, width) of the level.</span>
<span class="sd">        - **&#39;downsample&#39;**: Downsample level, where higher numbers indicate</span>
<span class="sd">            lower magnification and the highest magnification is 1.</span>
<span class="sd">        - **`height&#39;**: Height of the level.</span>
<span class="sd">        - **`height&#39;**: Width of the level.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">levels</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">level_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of list, with dimensions for each slide level.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">level_dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">level_downsamples</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Downsample of each level (starts at 1, increases with lower mag).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">level_downsamples</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">level_mpp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Microns-per-pixel (MPP) for each level.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">level_downsamples</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary of metadata loaded from the slide.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vendor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Slide scanner vendor, if available.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">OPS_VENDOR</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">properties</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="n">OPS_VENDOR</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the shape of the tile grid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">slide</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Backend-specific slide object.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__slide</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__slide</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__slide</span> <span class="o">=</span> <span class="n">wsi_reader</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mpp_override</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_reader_kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__slide</span>  <span class="c1"># type: ignore</span>
        <span class="k">except</span> <span class="n">errors</span><span class="o">.</span><span class="n">SlideMissingMPPError</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">SlideLoadError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Error loading slide </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shortname</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qc_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns union of all QC masks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_qc_mask</span><span class="p">()</span>

    <span class="c1"># --- Alignment --------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">align_to</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">slide</span><span class="p">:</span> <span class="s2">&quot;WSI&quot;</span><span class="p">,</span>
        <span class="n">apply</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">finetune_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalizer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;reinhard_mask&#39;</span><span class="p">,</span>
        <span class="n">allow_errors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Align this slide to another slide.</span>

<span class="sd">        Alignment is performed by first aligning thumbnails at low magnification</span>
<span class="sd">        (mpp = 8), then progressively fine-tuning alignment at increasing</span>
<span class="sd">        magnification (mpp = 1, 0.5, 0.25), focused on a dense tissue region.</span>
<span class="sd">        The densest tissue region is identified using the QC mask, if available,</span>
<span class="sd">        otherwise via Otsu thresholding.</span>

<span class="sd">        Args:</span>
<span class="sd">            slide (:class:`slideflow.WSI`): Slide to align to.</span>
<span class="sd">            apply (bool): Whether to apply the alignment to the slide.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            finetune_depth (Optional[List[int]]): List of magnifications at</span>
<span class="sd">                which to fine-tune alignment. Defaults to [1, 0.5, 0.25].</span>
<span class="sd">            normalizer (str, optional): Stain normalization method to use.</span>
<span class="sd">                Defaults to &#39;reinhard_mask&#39;.</span>
<span class="sd">            allow_errors (bool): Whether to allow and ignore alignment errors</span>
<span class="sd">                when finetuning at higher magnification. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple of (x, y) offset and MSE of initial alignment.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: If ``slide`` is not a :class:`slideflow.WSI` object.</span>

<span class="sd">            AlignmentError: If initial, thumbnail-based alignment fails, or</span>
<span class="sd">                if finetuning alignment fails at any magnification and</span>
<span class="sd">                ``allow_errors`` is False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slide</span><span class="p">,</span> <span class="n">WSI</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only align to another slide.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">finetune_depth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">finetune_depth</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]</span>

        <span class="c1"># Steps:</span>
        <span class="c1"># 1. Identify tissue region as target for alignment.</span>
        <span class="c1"># 2. Rough align with low-mag thumbnails (mpp = 8).</span>
        <span class="c1"># 3. Fine-tune alignment at a dense tissue region (mpp = 1, 0.5, 0.25).</span>

        <span class="c1"># --- 1. Identify tissue regions as targets for alignment. ------------</span>

        <span class="c1"># Use QC mask (.qc_mask) if available, otherwise calculate one.</span>
        <span class="c1"># Target should be the centroid of unmasked tissue regions, but</span>
        <span class="c1"># there may be multiple distinct tissue regions.</span>

        <span class="c1"># First, grab the QC mask, or make one if it is not available.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Applying Otsu thresholding to identify tissue regions.&quot;</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">qc</span><span class="o">.</span><span class="n">Otsu</span><span class="p">()(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Next, fill holes and remove small peaks through gaussian blur,</span>
        <span class="c1"># thresholding, and morphological closing.</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Filling holes and removing small peaks in tissue mask.&quot;</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">binary_closing</span><span class="p">(</span>
            <span class="n">skimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">,</span>
            <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">disk</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># For each pixel in the mask, calculate the nearest distance to an</span>
        <span class="c1"># unmasked pixel. This will assist us with finding the densest areas</span>
        <span class="c1"># of tissue.</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Calculating distance transform of tissue mask.&quot;</span><span class="p">)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Find the coordinates of the pixel with the highest average distance.</span>
        <span class="c1"># This is the center of the densest tissue region.</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Identifying target for alignment.&quot;</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">distances</span><span class="p">),</span> <span class="n">distances</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Convert from mask coordinates to slide coordinates.</span>
        <span class="n">target</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="p">)</span>
        <span class="n">target_them</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span> <span class="o">/</span> <span class="n">slide</span><span class="o">.</span><span class="n">mpp</span><span class="p">))),</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span> <span class="o">/</span> <span class="n">slide</span><span class="o">.</span><span class="n">mpp</span><span class="p">)))</span>
        <span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Low-mag alignment complete.&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Target for alignment (us): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Target for alignment (them, pre-alignment): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_them</span><span class="p">))</span>

        <span class="c1"># --- 2. Align low-mag thumbnails. ------------------------------------</span>

        <span class="c1"># Calculate thumbnails for alignment.</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Calculating low-mag thumbnails for alignment.&quot;</span><span class="p">)</span>
        <span class="n">our_thumb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thumb</span><span class="p">(</span><span class="n">mpp</span><span class="o">=</span><span class="mi">8</span><span class="p">))</span>
        <span class="n">their_thumb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slide</span><span class="o">.</span><span class="n">thumb</span><span class="p">(</span><span class="n">mpp</span><span class="o">=</span><span class="mi">8</span><span class="p">))</span>

        <span class="c1"># Stain normalization</span>
        <span class="k">if</span> <span class="n">normalizer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Aligning with stain normalization: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">normalizer</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">autoselect</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;opencv&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">StainNormalizer</span><span class="p">):</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">normalizer</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;normalizer must be a str or instance of StainNormalizer&quot;</span><span class="p">)</span>
            <span class="n">our_thumb</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">our_thumb</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">their_thumb</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">their_thumb</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>

        <span class="c1"># Align thumbnails and adjust for scale.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Aligning low-mag thumbnails (mpp=8)...&quot;</span><span class="p">)</span>
            <span class="n">alignment_raw</span><span class="p">,</span> <span class="n">mse</span> <span class="o">=</span> <span class="n">align_by_translation</span><span class="p">(</span>
                <span class="n">their_thumb</span><span class="p">,</span> <span class="n">our_thumb</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">calculate_mse</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">errors</span><span class="o">.</span><span class="n">AlignmentError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">AlignmentError</span><span class="p">(</span><span class="s2">&quot;Alignment failed at thumbnail (mpp=8)&quot;</span><span class="p">)</span>
        <span class="n">alignment</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">alignment_raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">8</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">))),</span>
                     <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">alignment_raw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">8</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">))))</span>
        <span class="n">alignment_them</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">alignment_raw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">8</span> <span class="o">/</span> <span class="n">slide</span><span class="o">.</span><span class="n">mpp</span><span class="p">))),</span>
                          <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">alignment_raw</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">8</span> <span class="o">/</span> <span class="n">slide</span><span class="o">.</span><span class="n">mpp</span><span class="p">))))</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Low-mag alignment (us): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alignment</span><span class="p">))</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Low-mag alignment (them): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alignment_them</span><span class="p">))</span>

        <span class="c1"># --- 3. Fine-tune alignment at tissue regions. -----------------------</span>

        <span class="c1"># Get the coordinates of the tissue region in both slides.</span>
        <span class="k">for</span> <span class="n">finetune_mpp</span> <span class="ow">in</span> <span class="n">finetune_depth</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">finetune_mpp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">finetune_mpp</span> <span class="o">&lt;</span> <span class="n">slide</span><span class="o">.</span><span class="n">mpp</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Skipping finetune at mpp=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finetune_mpp</span><span class="p">))</span>
                <span class="k">continue</span>
            <span class="c1"># Us</span>
            <span class="n">our_window_size</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">512</span> <span class="o">*</span> <span class="p">(</span><span class="n">finetune_mpp</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">))),</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">512</span> <span class="o">*</span> <span class="p">(</span><span class="n">finetune_mpp</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">)))</span>
            <span class="p">)</span>
            <span class="n">our_top_left</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">our_window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">))),</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">target</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">our_window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>
            <span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Extracting mpp=</span><span class="si">{}</span><span class="s2"> alignment window (ours) at window_size=</span><span class="si">{}</span><span class="s2">, top_left=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">finetune_mpp</span><span class="p">,</span> <span class="n">our_window_size</span><span class="p">,</span> <span class="n">our_top_left</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">our_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">read_from_pyramid</span><span class="p">(</span>
                <span class="n">top_left</span><span class="o">=</span><span class="n">our_top_left</span><span class="p">,</span>
                <span class="n">window_size</span><span class="o">=</span><span class="n">our_window_size</span><span class="p">,</span>
                <span class="n">target_size</span><span class="o">=</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">),</span>
                <span class="n">convert</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span>
                <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">pad_missing</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="c1"># Them</span>
            <span class="n">their_window_size</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">512</span> <span class="o">*</span> <span class="p">(</span><span class="n">finetune_mpp</span><span class="o">/</span><span class="n">slide</span><span class="o">.</span><span class="n">mpp</span><span class="p">))),</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">512</span> <span class="o">*</span> <span class="p">(</span><span class="n">finetune_mpp</span><span class="o">/</span><span class="n">slide</span><span class="o">.</span><span class="n">mpp</span><span class="p">)))</span>
            <span class="p">)</span>
            <span class="n">their_top_left</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">target_them</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">their_window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span> <span class="o">+</span> <span class="n">alignment_them</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">target_them</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">their_window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span> <span class="o">+</span> <span class="n">alignment_them</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Extracting mpp=</span><span class="si">{}</span><span class="s2"> alignment window (theirs) at window_size=</span><span class="si">{}</span><span class="s2">, top_left=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">finetune_mpp</span><span class="p">,</span> <span class="n">their_window_size</span><span class="p">,</span> <span class="n">their_top_left</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">their_region</span> <span class="o">=</span> <span class="n">slide</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">read_from_pyramid</span><span class="p">(</span>
                <span class="n">top_left</span><span class="o">=</span><span class="n">their_top_left</span><span class="p">,</span>
                <span class="n">window_size</span><span class="o">=</span><span class="n">their_window_size</span><span class="p">,</span>
                <span class="n">target_size</span><span class="o">=</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">),</span>
                <span class="n">convert</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span>
                <span class="n">flatten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">pad_missing</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">normalizer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">our_region</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">our_region</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">their_region</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">their_region</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">rough_alignment</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">_find_translation_matrix</span><span class="p">(</span><span class="n">their_region</span><span class="p">,</span> <span class="n">our_region</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">search_window</span><span class="o">=</span><span class="mi">53</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">cv2</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="n">rough_alignment</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Initial rough alignment failed at mpp=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finetune_mpp</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Initial rough alignment complete at mpp=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finetune_mpp</span><span class="p">))</span>

            <span class="c1"># Finetune alignment on this region.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">alignment_fine</span> <span class="o">=</span> <span class="n">align_by_translation</span><span class="p">(</span><span class="n">their_region</span><span class="p">,</span> <span class="n">our_region</span><span class="p">,</span> <span class="nb">round</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">warp_matrix</span><span class="o">=</span><span class="n">rough_alignment</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">errors</span><span class="o">.</span><span class="n">AlignmentError</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Alignment failed at finetuning (mpp=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finetune_mpp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">allow_errors</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">AlignmentError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alignment</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">alignment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">alignment_fine</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">finetune_mpp</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">))),</span>
                    <span class="n">alignment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">alignment_fine</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">finetune_mpp</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">)))</span>
                <span class="p">)</span>
                <span class="n">alignment_them</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">alignment_them</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">alignment_fine</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">finetune_mpp</span><span class="o">/</span><span class="n">slide</span><span class="o">.</span><span class="n">mpp</span><span class="p">))),</span>
                    <span class="n">alignment_them</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">alignment_fine</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">finetune_mpp</span><span class="o">/</span><span class="n">slide</span><span class="o">.</span><span class="n">mpp</span><span class="p">)))</span>
                <span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Finetune alignment complete at mpp=</span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finetune_mpp</span><span class="p">))</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Finetuned alignment (us) at mpp=</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finetune_mpp</span><span class="p">,</span> <span class="n">alignment</span><span class="p">))</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Finetuned alignment (them) at mpp=</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">finetune_mpp</span><span class="p">,</span> <span class="n">alignment_them</span><span class="p">))</span>

        <span class="c1"># If not applying alignment, return the base alignment and MSE.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">apply</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Slide aligned with MSE </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mse</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">mse</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># Apply alignment.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">alignment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="n">Alignment</span><span class="o">.</span><span class="n">from_translation</span><span class="p">(</span>
            <span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">coord_to_raw</span><span class="p">(</span><span class="o">*</span><span class="n">alignment</span><span class="p">),</span>
            <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="n">slide</span><span class="o">.</span><span class="n">mpp</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Slide aligned with MSE </span><span class="si">{:.2f}</span><span class="s2">. Origin set to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">mse</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span>
        <span class="p">))</span>

        <span class="c1"># Rebuild coordinates and reapply QC, if present.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_coord</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_non_roi_qc</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_qc_mask</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">alignment</span><span class="p">,</span> <span class="n">mse</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span> <span class="nf">align_tiles_to</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">slide</span><span class="p">:</span> <span class="s2">&quot;WSI&quot;</span><span class="p">,</span>
        <span class="n">normalizer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;reinhard_mask&#39;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">allow_errors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">mask_on_fail</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">align_by</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;fit&#39;</span><span class="p">,</span>
        <span class="n">ignore_outliers</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">num_workers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Align tiles to another slide.</span>

<span class="sd">        Differs from :meth:`slideflow.WSI.align_to` in that it aligns each</span>
<span class="sd">        tile individually, rather than the slide as a whole. This is useful</span>
<span class="sd">        when aligning slides with distortion, whose alignment may drift across</span>
<span class="sd">        the slide.</span>

<span class="sd">        Args:</span>
<span class="sd">            slide (:class:`slideflow.WSI`): Slide to align to.</span>
<span class="sd">            normalizer (str, optional): Stain normalization method to use.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            allow_errors (bool): Whether to allow and ignore alignment errors</span>
<span class="sd">                when finetuning alignment fails at any magnification and</span>
<span class="sd">                ``allow_errors`` is False. Defaults to True.</span>
<span class="sd">            mask_on_fail (bool): Whether to mask tiles that fail alignment.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            align_by (str): Either &#39;tile&#39; or &#39;fit&#39;. If &#39;tile&#39;, tiles are</span>
<span class="sd">                aligned individually. If &#39;fit&#39;, tiles are aligned by fitting</span>
<span class="sd">                a plane to the alignment of all tiles. Defaults to &#39;tile&#39;.</span>
<span class="sd">            ignore_outliers (bool): Whether to ignore outliers when fitting</span>
<span class="sd">                a plane to tile alignment. Defaults to True.</span>
<span class="sd">            **kwargs: Keyword arguments passed to :meth:`slideflow.WSI.align_to`.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If ``align_by`` is not &#39;tile&#39; or &#39;fit&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Alignment grid, with shape = (grid_x, grid_y, 2).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">align_by</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;tile&#39;</span><span class="p">,</span> <span class="s1">&#39;fit&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;align_by must be &#39;tile&#39; or &#39;median&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># Stain normalizer.</span>
        <span class="k">if</span> <span class="n">normalizer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">normalizer</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">autoselect</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;opencv&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">StainNormalizer</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;normalizer must be a str or instance of StainNormalizer&quot;</span><span class="p">)</span>

        <span class="c1"># Perform coarse alignment.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_to</span><span class="p">(</span>
            <span class="n">slide</span><span class="p">,</span> <span class="n">apply</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalizer</span><span class="o">=</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">allow_errors</span><span class="o">=</span><span class="n">allow_errors</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c1"># Finetune alignment at each tile location.</span>
        <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

        <span class="n">ctx</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s1">&#39;spawn&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">sf</span><span class="o">.</span><span class="n">slide_backend</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;libvips&#39;</span> <span class="k">else</span> <span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="s1">&#39;fork&#39;</span><span class="p">)</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">num_workers</span> <span class="ow">or</span> <span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">num_cpu</span><span class="p">())</span>

        <span class="n">alignment_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">half_extract_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">idx_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tile_alignment</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span>
                                        <span class="n">partial</span><span class="p">(</span><span class="n">calc_alignment</span><span class="p">,</span>
                                                <span class="n">us</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                                                <span class="n">them</span><span class="o">=</span><span class="n">slide</span><span class="p">,</span>
                                                <span class="n">n</span><span class="o">=</span><span class="n">normalizer</span><span class="p">),</span>
                                        <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">)),</span>
                                      <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Aligning tiles...&quot;</span><span class="p">,</span>
                                      <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">)):</span>
            <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span>
            <span class="k">if</span> <span class="n">tile_alignment</span> <span class="o">==</span> <span class="s1">&#39;error&#39;</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Tile alignment failed at x=</span><span class="si">{}</span><span class="s2">, y=</span><span class="si">{}</span><span class="s2"> (grid </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">allow_errors</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="n">tile_alignment</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">AlignmentError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tile_alignment</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mask_on_fail</span> <span class="ow">and</span> <span class="n">align_by</span> <span class="o">==</span> <span class="s1">&#39;tile&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">idx_to_remove</span> <span class="o">+=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">tile_alignment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">idx_to_remove</span> <span class="o">+=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">tile_alignment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pixel_ratio</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">)</span>
                <span class="n">x_adjust</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">tile_alignment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pixel_ratio</span><span class="p">))</span>
                <span class="n">y_adjust</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">tile_alignment</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">pixel_ratio</span><span class="p">))</span>
                <span class="n">x_base</span><span class="p">,</span> <span class="n">y_base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">coord_to_raw</span><span class="p">(</span>
                    <span class="n">x</span> <span class="o">+</span> <span class="n">half_extract_px</span><span class="p">,</span>
                    <span class="n">y</span> <span class="o">+</span> <span class="n">half_extract_px</span>
                <span class="p">)</span>
                <span class="n">x_base_adjusted</span><span class="p">,</span> <span class="n">y_base_adjusted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">coord_to_raw</span><span class="p">(</span>
                    <span class="n">x</span> <span class="o">+</span> <span class="n">half_extract_px</span> <span class="o">+</span> <span class="n">x_adjust</span><span class="p">,</span>
                    <span class="n">y</span> <span class="o">+</span> <span class="n">half_extract_px</span> <span class="o">+</span> <span class="n">y_adjust</span>
                <span class="p">)</span>
                <span class="n">x_base_adjustment</span> <span class="o">=</span> <span class="n">x_base_adjusted</span> <span class="o">-</span> <span class="n">x_base</span>
                <span class="n">y_base_adjustment</span> <span class="o">=</span> <span class="n">y_base_adjusted</span> <span class="o">-</span> <span class="n">y_base</span>
                <span class="n">alignment_coords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_base_adjustment</span><span class="p">,</span> <span class="n">y_base_adjustment</span><span class="p">])</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Tile alignment complete at x=</span><span class="si">{}</span><span class="s2">, y=</span><span class="si">{}</span><span class="s2"> (grid </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">): adjust by </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">x_adjust</span><span class="p">,</span> <span class="n">y_adjust</span>
                <span class="p">))</span>

        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">coord_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_masked_coord</span><span class="p">()</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">coord_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">idx_to_remove</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">coord_mask</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">all_alignment_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">alignment_coords</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="n">coord_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">coord_to_raw</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="o">~</span><span class="n">coord_mask</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">half_extract_px</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="o">~</span><span class="n">coord_mask</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">half_extract_px</span>
        <span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Removing </span><span class="si">{}</span><span class="s2"> indices with failed alignment. Max coord size: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_to_remove</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">align_by</span> <span class="o">==</span> <span class="s1">&#39;fit&#39;</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Fitting to </span><span class="si">{}</span><span class="s2"> coordinates.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="o">~</span><span class="n">coord_mask</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>
            <span class="n">x_adjustment_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span>
                <span class="n">coord_raw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">coord_raw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">all_alignment_coords</span><span class="p">[</span><span class="o">~</span><span class="n">coord_mask</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">))</span>
            <span class="n">y_adjustment_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span>
                <span class="n">coord_raw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">coord_raw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">all_alignment_coords</span><span class="p">[</span><span class="o">~</span><span class="n">coord_mask</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="p">))</span>

            <span class="k">def</span> <span class="nf">build_aligned_coords</span><span class="p">(</span><span class="n">x_centroid</span><span class="p">,</span> <span class="n">x_normal</span><span class="p">,</span> <span class="n">y_centroid</span><span class="p">,</span> <span class="n">y_normal</span><span class="p">):</span>
                <span class="n">coord_on_plane</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">coord_on_plane</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">coord_on_plane</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">):</span>
                    <span class="c1"># Convert coordinates to raw base layer coordinates</span>
                    <span class="n">bx</span><span class="p">,</span> <span class="n">by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">coord_to_raw</span><span class="p">(</span>
                        <span class="n">x</span> <span class="o">+</span> <span class="n">half_extract_px</span><span class="p">,</span>
                        <span class="n">y</span> <span class="o">+</span> <span class="n">half_extract_px</span>
                    <span class="p">)</span>
                    <span class="c1"># Align to raw base layer coordinates</span>
                    <span class="n">coord_on_plane</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">z_on_plane</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span> <span class="n">by</span><span class="p">,</span> <span class="n">x_centroid</span><span class="p">,</span> <span class="n">x_normal</span><span class="p">))),</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">z_on_plane</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span> <span class="n">by</span><span class="p">,</span> <span class="n">y_centroid</span><span class="p">,</span> <span class="n">y_normal</span><span class="p">)))</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">coord_on_plane</span>

            <span class="n">x_centroid</span><span class="p">,</span> <span class="n">x_normal</span> <span class="o">=</span> <span class="n">best_fit_plane</span><span class="p">(</span><span class="n">x_adjustment_coordinates</span><span class="p">)</span>
            <span class="n">y_centroid</span><span class="p">,</span> <span class="n">y_normal</span> <span class="o">=</span> <span class="n">best_fit_plane</span><span class="p">(</span><span class="n">y_adjustment_coordinates</span><span class="p">)</span>
            <span class="n">fit_alignment</span> <span class="o">=</span> <span class="n">build_aligned_coords</span><span class="p">(</span><span class="n">x_centroid</span><span class="p">,</span> <span class="n">x_normal</span><span class="p">,</span> <span class="n">y_centroid</span><span class="p">,</span> <span class="n">y_normal</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ignore_outliers</span><span class="p">:</span>
                <span class="c1"># Calculate outlier threshold (90th percentile)</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">all_alignment_coords</span> <span class="o">-</span> <span class="n">fit_alignment</span><span class="p">)</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="o">~</span><span class="n">diff</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>
                <span class="n">all_alignment_coords</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">coord_mask</span><span class="p">[</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">fit_alignment</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">all_alignment_coords</span><span class="o">.</span><span class="n">mask</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Re-fitting to </span><span class="si">{}</span><span class="s2"> coordinates, ignoring outliers.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="o">~</span><span class="n">coord_mask</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>

                <span class="n">coord_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">coord_to_raw</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="o">~</span><span class="n">coord_mask</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">half_extract_px</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="o">~</span><span class="n">coord_mask</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">half_extract_px</span>
                <span class="p">)</span>

                <span class="c1"># Recalculate fit without outliers</span>
                <span class="n">x_adjustment_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span>
                    <span class="n">coord_raw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">coord_raw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">all_alignment_coords</span><span class="p">[</span><span class="o">~</span><span class="n">coord_mask</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">))</span>
                <span class="n">y_adjustment_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span>
                    <span class="n">coord_raw</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">coord_raw</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">all_alignment_coords</span><span class="p">[</span><span class="o">~</span><span class="n">coord_mask</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="p">))</span>

                <span class="n">x_centroid</span><span class="p">,</span> <span class="n">x_normal</span> <span class="o">=</span> <span class="n">best_fit_plane</span><span class="p">(</span><span class="n">x_adjustment_coordinates</span><span class="p">)</span>
                <span class="n">y_centroid</span><span class="p">,</span> <span class="n">y_normal</span> <span class="o">=</span> <span class="n">best_fit_plane</span><span class="p">(</span><span class="n">y_adjustment_coordinates</span><span class="p">)</span>

                <span class="n">all_alignment_coords</span> <span class="o">=</span> <span class="n">build_aligned_coords</span><span class="p">(</span><span class="n">x_centroid</span><span class="p">,</span> <span class="n">x_normal</span><span class="p">,</span> <span class="n">y_centroid</span><span class="p">,</span> <span class="n">y_normal</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_alignment_coords</span> <span class="o">=</span> <span class="n">fit_alignment</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="n">Alignment</span><span class="o">.</span><span class="n">from_fit</span><span class="p">(</span>
                <span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">coord_to_raw</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">),</span>
                <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="n">slide</span><span class="o">.</span><span class="n">mpp</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">),</span>
                <span class="n">centroid</span><span class="o">=</span><span class="p">(</span><span class="n">x_centroid</span><span class="p">,</span> <span class="n">y_centroid</span><span class="p">),</span>
                <span class="n">normal</span><span class="o">=</span><span class="p">(</span><span class="n">x_normal</span><span class="p">,</span> <span class="n">y_normal</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">all_alignment_coords</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">continue</span>

            <span class="n">bx</span><span class="p">,</span> <span class="n">by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">coord_to_raw</span><span class="p">(</span>
                <span class="n">x</span> <span class="o">+</span> <span class="n">half_extract_px</span><span class="p">,</span>
                <span class="n">y</span> <span class="o">+</span> <span class="n">half_extract_px</span>
            <span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">raw_to_coord</span><span class="p">(</span>
                <span class="n">bx</span> <span class="o">+</span> <span class="n">all_alignment_coords</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">by</span> <span class="o">+</span> <span class="n">all_alignment_coords</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">half_extract_px</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">half_extract_px</span>

        <span class="c1"># Delete tiles that failed to align.</span>
        <span class="k">if</span> <span class="n">idx_to_remove</span> <span class="ow">and</span> <span class="n">align_by</span> <span class="o">==</span> <span class="s1">&#39;tile&#39;</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Removing </span><span class="si">{}</span><span class="s2"> tiles that failed to align.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_to_remove</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">,</span> <span class="n">idx_to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">align_by</span> <span class="o">!=</span> <span class="s1">&#39;fit&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="n">Alignment</span><span class="o">.</span><span class="n">from_coord</span><span class="p">(</span>
                <span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">coord_to_raw</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">),</span>
                <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="n">slide</span><span class="o">.</span><span class="n">mpp</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">),</span>
                <span class="n">coord</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span>
            <span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Slide alignment complete and finetuned at each unmasked tile location.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">all_alignment_coords</span>

    <span class="k">def</span> <span class="nf">apply_alignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alignment</span><span class="p">:</span> <span class="n">Alignment</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply alignment to the slide.</span>

<span class="sd">        Args:</span>
<span class="sd">            alignment (slideflow.slide.Alignment): Alignment object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alignment</span> <span class="o">=</span> <span class="n">alignment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">raw_to_coord</span><span class="p">(</span><span class="o">*</span><span class="n">alignment</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alignment</span><span class="o">.</span><span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">coord</span>
        <span class="k">elif</span> <span class="n">alignment</span><span class="o">.</span><span class="n">centroid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_coord</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">apply_qc_mask</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_coord</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">apply_qc_mask</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">alignment</span><span class="o">.</span><span class="n">centroid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">x_centroid</span><span class="p">,</span> <span class="n">y_centroid</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">centroid</span>
                <span class="n">x_normal</span><span class="p">,</span> <span class="n">y_normal</span> <span class="o">=</span> <span class="n">alignment</span><span class="o">.</span><span class="n">normal</span>
                <span class="n">half_extract_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">):</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">xi</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_stride</span><span class="o">/</span><span class="n">alignment</span><span class="o">.</span><span class="n">scale</span><span class="p">)))</span> <span class="o">*</span> <span class="n">alignment</span><span class="o">.</span><span class="n">scale</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">yi</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_stride</span><span class="o">/</span><span class="n">alignment</span><span class="o">.</span><span class="n">scale</span><span class="p">)))</span> <span class="o">*</span> <span class="n">alignment</span><span class="o">.</span><span class="n">scale</span>
                    <span class="n">x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">bx</span><span class="p">,</span> <span class="n">by</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">coord_to_raw</span><span class="p">(</span>
                        <span class="n">x</span> <span class="o">+</span> <span class="n">half_extract_px</span><span class="p">,</span>
                        <span class="n">y</span> <span class="o">+</span> <span class="n">half_extract_px</span>
                    <span class="p">)</span>
                    <span class="n">adjust_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">z_on_plane</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span> <span class="n">by</span><span class="p">,</span> <span class="n">x_centroid</span><span class="p">,</span> <span class="n">x_normal</span><span class="p">)))</span>
                    <span class="n">adjust_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">z_on_plane</span><span class="p">(</span><span class="n">bx</span><span class="p">,</span> <span class="n">by</span><span class="p">,</span> <span class="n">y_centroid</span><span class="p">,</span> <span class="n">y_normal</span><span class="p">)))</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">raw_to_coord</span><span class="p">(</span><span class="n">bx</span> <span class="o">+</span> <span class="n">adjust_x</span><span class="p">,</span> <span class="n">by</span> <span class="o">+</span> <span class="n">adjust_y</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">half_extract_px</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">half_extract_px</span>

    <span class="k">def</span> <span class="nf">load_alignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load alignment from a file.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str): Path to alignment file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_alignment</span><span class="p">(</span><span class="n">Alignment</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>

    <span class="c1"># --- All other functions -----------------------------------------------</span>

    <span class="k">def</span> <span class="nf">apply_qc_mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">QCMask</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">filter_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">is_roi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Image&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply custom slide-level QC by filtering grid coordinates.</span>

<span class="sd">        The mask should have a shape (height, width) proportional to the</span>
<span class="sd">        slide&#39;s dimensions.</span>

<span class="sd">        If the mask is numerical, the mask is thresholded at filter_threshold,</span>
<span class="sd">        with values above the threshold indicating a region to discard.</span>

<span class="sd">        If the mask is a boolean array, True indicates a region to</span>
<span class="sd">        discard and False indicates a region to keep.</span>

<span class="sd">        If the mask is a QCMask, the filter_threshold is ignored.</span>

<span class="sd">        Args:</span>
<span class="sd">            mask (np.ndarray or :class:`slideflow.slide.QCMask`, optional):</span>
<span class="sd">                Boolean QC mask array or ``QCMask`` object. If None, will</span>
<span class="sd">                re-apply the current masks. Defaults to None.</span>
<span class="sd">            filter_threshold (float): Percent of a tile detected as</span>
<span class="sd">                background that will trigger a tile to be discarded.</span>
<span class="sd">                Only used if ``mask`` is an np.ndarray.</span>
<span class="sd">                Defaults to 0.6.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            is_roi (bool): Whether the mask is an ROI mask. Only used if ``mask``</span>
<span class="sd">                is an ``np.ndarray``. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Image: Image of applied QC mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no mask is provided and none has been previously applied,</span>
        <span class="c1"># raise an error.</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qc_masks</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">QCError</span><span class="p">(</span><span class="s2">&quot;No QC mask available&quot;</span><span class="p">)</span>

        <span class="c1"># If no mask provided, re-apply the current masks.</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">qc_mask</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_masks</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">apply_qc_mask</span><span class="p">(</span><span class="n">qc_mask</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qc_mask</span><span class="p">))</span>

        <span class="c1"># Verify that the mask is a np.ndarray or QCMask.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">QCMask</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;mask must be a np.ndarray or QCMask&quot;</span><span class="p">)</span>

        <span class="c1"># Set the filter threshold if not provided.</span>
        <span class="c1"># If mask is a QCMask, use its filter_threshold.</span>
        <span class="c1"># Otherwise, default to 0.6.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">QCMask</span><span class="p">)</span> <span class="ow">and</span> <span class="n">filter_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_threshold</span> <span class="o">=</span> <span class="mf">0.6</span>
        <span class="k">elif</span> <span class="n">filter_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">QCMask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;filter_threshold cannot be provided if mask is a QCMask&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">filter_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_threshold</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">filter_threshold</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># If the provided mask is an np.ndarray, convert it to a QCMask.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">QCMask</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">QCMask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">filter_threshold</span><span class="o">=</span><span class="n">filter_threshold</span><span class="p">,</span> <span class="n">is_roi</span><span class="o">=</span><span class="n">is_roi</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qc_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

        <span class="c1"># Apply the mask to the grid.</span>
        <span class="n">downsample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">qc_ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">downsample</span>
        <span class="n">qc_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span> <span class="o">*</span> <span class="n">qc_ratio</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># x and y are top-left coordinates for the tile.</span>
            <span class="n">qc_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">qc_ratio</span><span class="p">))</span>
            <span class="n">qc_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">qc_ratio</span><span class="p">))</span>
            <span class="n">submask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">qc_y</span><span class="p">:(</span><span class="n">qc_y</span><span class="o">+</span><span class="n">qc_width</span><span class="p">),</span> <span class="n">qc_x</span><span class="p">:(</span><span class="n">qc_x</span><span class="o">+</span><span class="n">qc_width</span><span class="p">)]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">submask</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">submask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">filter_threshold</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Update the estimated number of tiles.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimated_num_tiles</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

        <span class="c1"># Return an image of the applied mask.</span>
        <span class="k">return</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qc_mask</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">apply_segmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segmentation</span><span class="p">:</span> <span class="s2">&quot;sf.cellseg.Segmentation&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply cell segmentation to the slide.</span>

<span class="sd">        This sets the coordinates to the centroids of the segmentation.</span>

<span class="sd">        Args:</span>
<span class="sd">            segmentation (slideflow.cellseg.Segmentation): Segmentation object</span>
<span class="sd">                to apply.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Filter out masks outside of ROIs, if present.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_rois</span><span class="p">():</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applying </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">)</span><span class="si">}</span><span class="s2"> ROIs to segmentation.&quot;</span><span class="p">)</span>
            <span class="n">rois</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rois</span><span class="p">(</span><span class="n">ignore_artifact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">segmentation</span><span class="o">.</span><span class="n">apply_rois</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">poly</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rois</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">slide</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">segmentation</span><span class="o">.</span><span class="n">slide</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segmentation</span> <span class="o">=</span> <span class="n">segmentation</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">centroids</span><span class="p">(</span><span class="n">wsi_dim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">centroids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">centroids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)),</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nonzero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_coord</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_coord</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">][</span><span class="n">nonzero</span><span class="p">]</span> <span class="o">-=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">estimated_num_tiles</span> <span class="o">=</span> <span class="n">centroids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate area (mm^2) of slide that passes QC masking.&quot;&quot;&quot;</span>
        <span class="n">dim_x</span><span class="p">,</span> <span class="n">dim_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">total_area_in_sq_microns</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">dim_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_mask</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qc_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">area_in_sq_microns</span> <span class="o">=</span> <span class="n">p</span> <span class="o">*</span> <span class="n">total_area_in_sq_microns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">area_in_sq_microns</span> <span class="o">=</span> <span class="n">total_area_in_sq_microns</span>
        <span class="n">area_in_sq_mm</span> <span class="o">=</span> <span class="n">area_in_sq_microns</span> <span class="o">*</span> <span class="mf">1e-6</span>
        <span class="k">return</span> <span class="n">area_in_sq_mm</span>

    <span class="k">def</span> <span class="nf">build_generator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">whitespace_fraction</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">whitespace_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">grayspace_fraction</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">grayspace_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalizer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s2">&quot;slideflow.norm.StainNormalizer&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalizer_source</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">context_normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">num_processes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_progress</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">img_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;numpy&#39;</span><span class="p">,</span>
        <span class="n">full_core</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">yolo</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">draw_roi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">pool</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;mp.pool.Pool&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dry_run</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">lazy_iter</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">shard</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_tiles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">from_centroids</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">apply_masks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">deterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Builds a tile generator to extract tiles from this slide.</span>

<span class="sd">        Keyword args:</span>
<span class="sd">            shuffle (bool): Shuffle images during extraction.</span>
<span class="sd">            whitespace_fraction (float, optional): Range 0-1. Defaults to 1.</span>
<span class="sd">                Discard tiles with this fraction of whitespace. If 1, will not</span>
<span class="sd">                perform whitespace filtering.</span>
<span class="sd">            whitespace_threshold (int, optional): Range 0-255. Defaults to 230.</span>
<span class="sd">                Threshold above which a pixel (RGB average) is whitespace.</span>
<span class="sd">            grayspace_fraction (float, optional): Range 0-1. Defaults to 0.6.</span>
<span class="sd">                Discard tiles with this fraction of grayspace. If 1, will not</span>
<span class="sd">                perform grayspace filtering.</span>
<span class="sd">            grayspace_threshold (float, optional): Range 0-1. Defaults to 0.05.</span>
<span class="sd">                Pixels in HSV format with saturation below this threshold are</span>
<span class="sd">                considered grayspace.</span>
<span class="sd">            normalizer (str, optional): Normalization strategy to use on image</span>
<span class="sd">                tiles. Defaults to None.</span>
<span class="sd">            normalizer_source (str, optional): Stain normalization preset or</span>
<span class="sd">                path to a source image. Valid presets include &#39;v1&#39;, &#39;v2&#39;, and</span>
<span class="sd">                &#39;v3&#39;. If None, will use the default present (&#39;v3&#39;).</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            context_normalize (bool): If normalizing, use context from</span>
<span class="sd">                the rest of the slide when calculating stain matrix</span>
<span class="sd">                concentrations. Defaults to False (normalize each image tile</span>
<span class="sd">                as separate images).</span>
<span class="sd">            num_threads (int): If specified, will extract tiles with a</span>
<span class="sd">                ThreadPool using the specified number of threads. Cannot</span>
<span class="sd">                supply both `num_threads` and `num_processes`. Libvips is</span>
<span class="sd">                particularly slow with ThreadPools. Defaults to None in the</span>
<span class="sd">                Libvips backend, and the number of CPU cores when using cuCIM.</span>
<span class="sd">            num_processes (int): If specified, will extract tiles with a</span>
<span class="sd">                multiprocessing pool using the specified number of processes.</span>
<span class="sd">                Cannot supply both `num_threads` and `num_processes`.</span>
<span class="sd">                With the libvips backend, this defaults to half the number of</span>
<span class="sd">                CPU cores, and with cuCIM, this defaults to None.</span>
<span class="sd">            show_progress (bool, optional): Show a progress bar.</span>
<span class="sd">            img_format (str, optional): Image format. Either &#39;numpy&#39;, &#39;jpg&#39;,</span>
<span class="sd">                or &#39;png&#39;. Defaults to &#39;numpy&#39;.</span>
<span class="sd">            yolo (bool, optional): Include yolo-formatted tile-level ROI</span>
<span class="sd">                annotations in the return dictionary, under the key &#39;yolo&#39;.</span>
<span class="sd">                Defaults to False.</span>
<span class="sd">            draw_roi (bool, optional): Draws ROIs onto extracted tiles.</span>
<span class="sd">                Defaults to False.</span>
<span class="sd">            dry_run (bool, optional): Determine tiles that would be extracted,</span>
<span class="sd">                but do not export any images. Defaults to None.</span>
<span class="sd">            max_tiles (int, optional): Only extract this many tiles per slide.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            from_centroids (bool): Extract tiles from cell segmentation</span>
<span class="sd">                centroids, rather than in a grid-wise pattern. Requires that</span>
<span class="sd">                cell segmentation has already been applied with</span>
<span class="sd">                `WSI.apply_segmentation()`. Defaults to False.</span>
<span class="sd">            apply_masks (bool): Apply cell segmentation masks to tiles. Ignored</span>
<span class="sd">                if cell segmentation has been applied to the slide.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            deterministic (bool): Return tile images in reproducible,</span>
<span class="sd">                deterministic order. May slightly decrease iteration time.</span>
<span class="sd">                Defaults to True.</span>
<span class="sd">            shard (tuple(int, int), optional): If provided, will only extract</span>
<span class="sd">                tiles from the shard with index `shard[0]` out of `shard[1]`</span>
<span class="sd">                shards. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A generator that yields a dictionary with the keys:</span>

<span class="sd">                - ``&quot;image&quot;``: image data.</span>
<span class="sd">                - ``&quot;yolo&quot;``: yolo-formatted annotations, (x_center, y_center, width, height), optional.</span>
<span class="sd">                - ``&quot;grid&quot;``: (x, y) grid coordinates of the tile.</span>
<span class="sd">                - ``&quot;loc&quot;``: (x, y) coordinates of tile center, in base (level=0) dimension.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">num_threads</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
           <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_processes</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
           <span class="ow">and</span> <span class="n">num_threads</span> <span class="o">&gt;</span> <span class="mi">1</span>
           <span class="ow">and</span> <span class="n">num_processes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_threads and num_processes cannot both be &quot;</span>
                             <span class="s2">&quot;non-zero.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">shard</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
           <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shard</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">shard</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span>
                <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shard</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If shard is provided, it must be a tuple of &quot;</span>
                             <span class="s2">&quot;two int (shard_idx, shard_count)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">from_centroids</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">segmentation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot build generator from segmentation centroids; &quot;</span>
                <span class="s2">&quot;segmentation not yet applied. Use WSI.apply_segmentation().&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log_tile_extraction</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">estimated_num_tiles</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No tiles extracted for slide [green]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Set whitespace / grayspace fraction to defaults if not provided</span>
        <span class="k">if</span> <span class="n">whitespace_fraction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">whitespace_fraction</span> <span class="o">=</span> <span class="n">DEFAULT_WHITESPACE_FRACTION</span>
        <span class="k">if</span> <span class="n">whitespace_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">whitespace_threshold</span> <span class="o">=</span> <span class="n">DEFAULT_WHITESPACE_THRESHOLD</span>
        <span class="k">if</span> <span class="n">grayspace_fraction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grayspace_fraction</span> <span class="o">=</span> <span class="n">DEFAULT_GRAYSPACE_FRACTION</span>
        <span class="k">if</span> <span class="n">grayspace_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grayspace_threshold</span> <span class="o">=</span> <span class="n">DEFAULT_GRAYSPACE_THRESHOLD</span>

        <span class="c1"># Get information about highest level downsample, as we will filter</span>
        <span class="c1"># on that layer if downsampling is enabled</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enable_downsample</span><span class="p">:</span>
            <span class="n">downsamples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">level_downsamples</span><span class="p">)</span>
            <span class="n">filter_lev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">downsamples</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_px</span><span class="p">))</span>
            <span class="n">filter_downsample_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">level_downsamples</span><span class="p">[</span><span class="n">filter_lev</span><span class="p">]</span>
            <span class="n">lev_ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">level_downsamples</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample_level</span><span class="p">]</span>
            <span class="n">filter_downsample_ratio</span> <span class="o">=</span> <span class="n">filter_downsample_factor</span> <span class="o">//</span> <span class="n">lev_ds</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filter_lev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample_level</span>
            <span class="n">filter_downsample_ratio</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Prepare stain normalization</span>
        <span class="k">if</span> <span class="n">normalizer</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">StainNormalizer</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sf</span><span class="o">.</span><span class="n">slide_backend</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;cucim&#39;</span><span class="p">:</span>
                <span class="n">normalizer</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">autoselect</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
                    <span class="n">method</span><span class="o">=</span><span class="n">normalizer</span><span class="p">,</span>
                    <span class="n">source</span><span class="o">=</span><span class="n">normalizer_source</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Libvips with spawn multiprocessing</span>
                <span class="c1"># is not compatible with Tensorflow-native stain normalization</span>
                <span class="c1"># due to GPU memory issues</span>
                <span class="n">normalizer</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">StainNormalizer</span><span class="p">(</span><span class="n">normalizer</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="k">if</span> <span class="n">normalizer_source</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">normalizer</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">normalizer_source</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

        <span class="k">if</span> <span class="n">normalizer</span> <span class="ow">and</span> <span class="n">context_normalize</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">StainNormalizer</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Preparing whole-slide context for normalizer&quot;</span><span class="p">)</span>
            <span class="n">normalizer</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">w_args</span> <span class="o">=</span> <span class="n">SimpleNamespace</span><span class="p">(</span><span class="o">**</span><span class="p">{</span>
            <span class="s1">&#39;full_extract_px&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="p">,</span>
            <span class="s1">&#39;mpp_override&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mpp_override</span><span class="p">,</span>
            <span class="s1">&#39;reader_kwargs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reader_kwargs</span><span class="p">,</span>
            <span class="s1">&#39;grid&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span>
            <span class="s1">&#39;downsample_level&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample_level</span><span class="p">,</span>
            <span class="s1">&#39;filter_downsample_level&#39;</span><span class="p">:</span> <span class="n">filter_lev</span><span class="p">,</span>
            <span class="s1">&#39;filter_downsample_ratio&#39;</span><span class="p">:</span> <span class="n">filter_downsample_ratio</span><span class="p">,</span>
            <span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
            <span class="s1">&#39;extract_px&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_px</span><span class="p">,</span>
            <span class="s1">&#39;tile_px&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span>
            <span class="s1">&#39;full_stride&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_stride</span><span class="p">,</span>
            <span class="s1">&#39;normalizer&#39;</span><span class="p">:</span> <span class="n">normalizer</span><span class="p">,</span>
            <span class="s1">&#39;whitespace_fraction&#39;</span><span class="p">:</span> <span class="n">whitespace_fraction</span><span class="p">,</span>
            <span class="s1">&#39;whitespace_threshold&#39;</span><span class="p">:</span> <span class="n">whitespace_threshold</span><span class="p">,</span>
            <span class="s1">&#39;grayspace_fraction&#39;</span><span class="p">:</span> <span class="n">grayspace_fraction</span><span class="p">,</span>
            <span class="s1">&#39;grayspace_threshold&#39;</span><span class="p">:</span> <span class="n">grayspace_threshold</span><span class="p">,</span>
            <span class="s1">&#39;img_format&#39;</span><span class="p">:</span> <span class="n">img_format</span><span class="p">,</span>
            <span class="s1">&#39;yolo&#39;</span><span class="p">:</span> <span class="n">yolo</span><span class="p">,</span>
            <span class="s1">&#39;draw_roi&#39;</span><span class="p">:</span> <span class="n">draw_roi</span><span class="p">,</span>
            <span class="s1">&#39;dry_run&#39;</span><span class="p">:</span> <span class="n">dry_run</span><span class="p">,</span>
            <span class="s1">&#39;has_segmentation&#39;</span><span class="p">:</span> <span class="n">from_centroids</span>
        <span class="p">})</span>

        <span class="k">def</span> <span class="nf">generator</span><span class="p">():</span>
            <span class="k">nonlocal</span> <span class="n">pool</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">num_processes</span>
            <span class="n">should_close</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">n_extracted</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Skip tiles filtered out with QC or ROI</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">from_centroids</span><span class="p">:</span>
                <span class="n">non_roi_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="c1"># Shuffle coordinates to randomize extraction order</span>
                <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">non_roi_coord</span><span class="p">)</span>
                <span class="n">num_possible_tiles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_roi_coord</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">slideflow.cellseg</span> <span class="kn">import</span> <span class="n">seg_utils</span>

                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Building generator from segmentation centroids.&quot;</span><span class="p">)</span>
                <span class="n">nonzero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_coord</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">num_possible_tiles</span> <span class="o">=</span> <span class="n">nonzero</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">apply_masks</span><span class="p">:</span>
                    <span class="n">sparse</span> <span class="o">=</span> <span class="n">seg_utils</span><span class="o">.</span><span class="n">sparse_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segmentation</span><span class="o">.</span><span class="n">masks</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">_sparse_generator</span><span class="p">():</span>

                    <span class="k">def</span> <span class="nf">proc</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">apply_masks</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tile_mask</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sparse</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">c</span><span class="p">,</span> <span class="n">mask</span>

                    <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seg_coord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="n">nonzero</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                                <span class="k">yield</span> <span class="n">proc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seg_coord</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_coord</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]:</span>
                            <span class="k">yield</span> <span class="n">proc</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

                <span class="n">non_roi_coord</span> <span class="o">=</span> <span class="n">_sparse_generator</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">shard</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shard_idx</span><span class="p">,</span> <span class="n">shard_count</span> <span class="o">=</span> <span class="n">shard</span>
                <span class="n">sharded_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">non_roi_coord</span><span class="p">,</span> <span class="n">shard_count</span><span class="p">)</span>
                <span class="n">non_roi_coord</span> <span class="o">=</span> <span class="n">sharded_coords</span><span class="p">[</span><span class="n">shard_idx</span><span class="p">]</span>

            <span class="c1"># Set up worker pool</span>
            <span class="k">if</span> <span class="n">pool</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">num_threads</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num_processes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Libvips is extremely slow with ThreadPools.</span>
                    <span class="c1"># In the cuCIM backend, ThreadPools are used by default</span>
                    <span class="c1">#   to reduce memory utilization.</span>
                    <span class="c1"># In the Libvips backend, a multiprocessing pool is default</span>
                    <span class="c1">#   to significantly improve performance.</span>
                    <span class="n">n_cores</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">num_cpu</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">sf</span><span class="o">.</span><span class="n">slide_backend</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;libvips&#39;</span><span class="p">:</span>
                        <span class="n">num_processes</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n_cores</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">num_threads</span> <span class="o">=</span> <span class="n">n_cores</span>
                <span class="k">if</span> <span class="n">num_threads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num_threads</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Building generator ThreadPool(</span><span class="si">{</span><span class="n">num_threads</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                    <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">dummy</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
                    <span class="n">should_close</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">num_processes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num_processes</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ptype</span> <span class="o">=</span> <span class="s1">&#39;spawn&#39;</span> <span class="k">if</span> <span class="n">sf</span><span class="o">.</span><span class="n">slide_backend</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;libvips&#39;</span> <span class="k">else</span> <span class="s1">&#39;fork&#39;</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Building generator with Pool(</span><span class="si">{</span><span class="n">num_processes</span><span class="si">}</span><span class="s2">), &quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;type=</span><span class="si">{</span><span class="n">ptype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">ctx</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">get_context</span><span class="p">(</span><span class="n">ptype</span><span class="p">)</span>
                    <span class="n">pool</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
                        <span class="n">processes</span><span class="o">=</span><span class="n">num_processes</span><span class="p">,</span>
                        <span class="n">initializer</span><span class="o">=</span><span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">set_ignore_sigint</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">should_close</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Building generator without multithreading&quot;</span><span class="p">)</span>
                    <span class="k">def</span> <span class="nf">_generator</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">non_roi_coord</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">tile_worker</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">w_args</span><span class="p">)</span>
                    <span class="n">i_mapped</span> <span class="o">=</span> <span class="n">_generator</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Building generator with a shared pool&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
                <span class="n">pbar</span> <span class="o">=</span> <span class="n">Progress</span><span class="p">(</span><span class="n">transient</span><span class="o">=</span><span class="n">sf</span><span class="o">.</span><span class="n">getLoggingLevel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">)</span>
                <span class="n">task</span> <span class="o">=</span> <span class="n">pbar</span><span class="o">.</span><span class="n">add_task</span><span class="p">(</span><span class="s1">&#39;Extracting...&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">estimated_num_tiles</span><span class="p">)</span>
                <span class="n">pbar</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pbar</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">map_fn</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap</span> <span class="k">if</span> <span class="n">deterministic</span> <span class="k">else</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span>
                <span class="k">if</span> <span class="n">lazy_iter</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">max_tiles</span><span class="p">:</span>
                        <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">_processes</span><span class="p">,</span> <span class="n">max_tiles</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">_processes</span>
                    <span class="n">batched_coord</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">non_roi_coord</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>
                    <span class="k">def</span> <span class="nf">_generator</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">batched_coord</span><span class="p">:</span>
                            <span class="k">yield from</span> <span class="n">map_fn</span><span class="p">(</span>
                                <span class="n">partial</span><span class="p">(</span><span class="n">tile_worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">w_args</span><span class="p">),</span>
                                <span class="n">batch</span>
                            <span class="p">)</span>
                    <span class="n">i_mapped</span> <span class="o">=</span> <span class="n">_generator</span><span class="p">()</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">csize</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">estimated_num_tiles</span><span class="o">/</span><span class="n">pool</span><span class="o">.</span><span class="n">_processes</span><span class="p">),</span> <span class="mi">64</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using imap chunksize=</span><span class="si">{</span><span class="n">csize</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">i_mapped</span> <span class="o">=</span> <span class="n">map_fn</span><span class="p">(</span>
                        <span class="n">partial</span><span class="p">(</span><span class="n">tile_worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">w_args</span><span class="p">),</span>
                        <span class="n">non_roi_coord</span><span class="p">,</span>
                        <span class="n">chunksize</span><span class="o">=</span><span class="n">csize</span>
                    <span class="p">)</span>

            <span class="k">with</span> <span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">cleanup_progress</span><span class="p">(</span><span class="n">pbar</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i_mapped</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">show_progress</span><span class="p">:</span>
                        <span class="n">pbar</span><span class="o">.</span><span class="n">advance</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">pb</span><span class="o">.</span><span class="n">advance</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">result</span>
                        <span class="n">n_extracted</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">max_tiles</span> <span class="ow">and</span> <span class="n">n_extracted</span> <span class="o">&gt;=</span> <span class="n">max_tiles</span><span class="p">:</span>
                            <span class="k">break</span>

            <span class="k">if</span> <span class="n">should_close</span><span class="p">:</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="c1"># Reset stain normalizer context</span>
            <span class="k">if</span> <span class="n">normalizer</span> <span class="ow">and</span> <span class="n">context_normalize</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normalizer</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">StainNormalizer</span><span class="p">)</span>
                <span class="n">normalizer</span><span class="o">.</span><span class="n">clear_context</span><span class="p">()</span>

            <span class="n">name_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;[green]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shortname</span><span class="si">}</span><span class="s1">[/]&#39;</span>
            <span class="n">num_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">n_extracted</span><span class="si">}</span><span class="s1"> tiles of </span><span class="si">{</span><span class="n">num_possible_tiles</span><span class="si">}</span><span class="s1"> possible)&#39;</span>
            <span class="n">log_fn</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">info</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="k">else</span> <span class="n">log</span><span class="o">.</span><span class="n">debug</span>
            <span class="n">log_fn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finished tile extraction for </span><span class="si">{</span><span class="n">name_msg</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">num_msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">generator</span>

    <span class="k">def</span> <span class="nf">coord_to_grid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">anchor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;center&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the grid index of a tile by its base-level coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (int): x-coordinate of the tile, in base (level=0) dimension.</span>
<span class="sd">            y (int): y-coordinate of the tile, in base (level=0) dimension.</span>

<span class="sd">        Keyword args:</span>
<span class="sd">            anchor (str): Anchor point for the coordinates. Either &#39;topleft&#39;</span>
<span class="sd">                or &#39;center&#39;. Defaults to &#39;center&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[int, int]: Grid index of the tile.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If anchor is not &#39;topleft&#39; or &#39;center&#39;.</span>
<span class="sd">            IndexError: If tile is not found at the given coordinates.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;topleft&#39;</span><span class="p">,</span> <span class="s1">&#39;center&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;anchor must be &#39;topleft&#39; or &#39;center&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">&#39;center&#39;</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">-=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">-=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">coord_idx</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
        <span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_idx</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tile at coord=(</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">) not found&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coord_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">coord_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span>

    <span class="k">def</span> <span class="nf">dim_to_mpp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">mpp</span><span class="p">)</span> <span class="o">/</span> <span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">export_rois</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dest</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Export loaded ROIs to a given destination, in CSV format.</span>

<span class="sd">        ROIs are exported with the columns &#39;roi_name&#39;, &#39;x_base&#39;, and &#39;y_base&#39;.</span>
<span class="sd">        Coordinates are in base dimension (level 0) of the slide.</span>

<span class="sd">        Args:</span>
<span class="sd">            dest (str): Path to destination folder. If not provided, will</span>
<span class="sd">                export ROIs in the current folder. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">append_roi</span><span class="p">(</span><span class="n">roi</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">names</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">roi</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="n">names</span> <span class="o">+=</span> <span class="p">[</span><span class="n">roi</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">labels</span> <span class="o">+=</span> <span class="p">[</span><span class="n">roi</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">roi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">:</span>
            <span class="n">append_roi</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">roi</span><span class="o">.</span><span class="n">holes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">append_roi</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;roi_name&#39;</span><span class="p">:</span> <span class="n">names</span><span class="p">,</span>
            <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="n">labels</span><span class="p">,</span>
            <span class="s1">&#39;x_base&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
            <span class="s1">&#39;y_base&#39;</span><span class="p">:</span> <span class="n">y</span>
        <span class="p">})</span>
        <span class="k">if</span> <span class="n">dest</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.csv&#39;</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">)</span><span class="si">}</span><span class="s2"> ROIs exported to </span><span class="si">{</span><span class="n">abspath</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">abspath</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_qc_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the combined QC mask for the slide.</span>

<span class="sd">        Args:</span>
<span class="sd">            roi (bool): Whether to include ROI masks. Defaults to True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_all_masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_masks</span> <span class="k">if</span> <span class="p">(</span><span class="n">roi</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">is_roi</span><span class="p">))]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_all_masks</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">_all_masks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_all_masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">smallest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">)</span>
                               <span class="k">for</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_all_masks</span><span class="p">))</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">_all_masks</span><span class="p">[</span><span class="n">smallest</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">_all_masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_next</span> <span class="ow">in</span> <span class="n">_all_masks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">_next_m</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">_next</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">_next_m</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">get_masked_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a masked array of the coordinate grid, masked by QC.</span>

<span class="sd">        The returned masked array is of shape (n, 4), where n is the number of tiles.</span>
<span class="sd">        The columns are (x, y, grid_x, grid_y), where x and y are the</span>
<span class="sd">        top-left coordinates of the tile, and grid_x and grid_y are the</span>
<span class="sd">        grid indices of the tile.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">true_grid_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">linear_indices_of_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span>
        <span class="n">unmasked_coord_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span>
            <span class="n">linear_indices_of_coord</span><span class="p">,</span>
            <span class="n">true_grid_indices</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=~</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">unmasked_coord_indices</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_rois</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_artifact</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ROI</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list of ROIs.</span>

<span class="sd">        Args:</span>
<span class="sd">            ignore_artifact (bool): Ignore artifact ROIs. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[ROI]: List of ROI objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ignore_artifact</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">roi</span> <span class="k">for</span> <span class="n">roi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span> <span class="k">if</span> <span class="n">roi</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">artifact_labels</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span>

    <span class="k">def</span> <span class="nf">get_artifacts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ROI</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list of artifact ROIs.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[ROI]: List of artifact ROI objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">roi</span> <span class="k">for</span> <span class="n">roi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span> <span class="k">if</span> <span class="n">roi</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">artifact_labels</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_roi_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ROI</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get an ROI by its name.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): Name of the ROI.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ROI: ROI object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">roi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">roi</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">roi</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_tile_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anchor</span><span class="o">=</span><span class="s1">&#39;topleft&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a coordinate grid of all tiles, restricted to those that pass QC</span>
<span class="sd">        and any ROI filtering.</span>

<span class="sd">        The returned array is of shape (n, 4), where n is the number of tiles.</span>
<span class="sd">        The columns are (x, y, grid_x, grid_y), where x and y are the</span>
<span class="sd">        top-left coordinates of the tile, and grid_x and grid_y are the</span>
<span class="sd">        grid indices of the tile.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;topleft&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected `anchor` to be &#39;center&#39; or &#39;topleft&#39;&quot;</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">&#39;center&#39;</span><span class="p">:</span>
            <span class="n">c</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">c</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">get_tile_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a dataframe of tiles and associated ROI labels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Pandas dataframe of all tiles, with the following columns:</span>
<span class="sd">            - ``loc_x``: X-coordinate of tile center</span>
<span class="sd">            - ``loc_y``: Y-coordinate of tile center</span>
<span class="sd">            - ``grid_x``: X grid index of the tile</span>
<span class="sd">            - ``grid_y``: Y grid index of the tile</span>
<span class="sd">            - ``roi_name``: Name of the ROI if tile is in an ROI, else None</span>
<span class="sd">            - ``roi_desc``: Description of the ROI if tile is in ROI, else None</span>
<span class="sd">            - ``label``: ROI label, if present.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">roi_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">roi_desc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">roi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tile_roi</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">))</span>

            <span class="c1"># Convert from top-left to center coordinates</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">loc</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">])</span>
            <span class="n">roi_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">roi</span> <span class="k">else</span> <span class="n">roi</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">roi_desc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">roi</span> <span class="k">else</span> <span class="n">roi</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">roi</span> <span class="k">else</span> <span class="n">roi</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
            <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;loc_x&#39;</span><span class="p">:</span> <span class="n">loc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;loc_y&#39;</span><span class="p">:</span> <span class="n">loc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="s1">&#39;grid_x&#39;</span><span class="p">:</span> <span class="n">grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;grid_y&#39;</span><span class="p">:</span> <span class="n">grid</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="s1">&#39;roi_name&#39;</span><span class="p">:</span> <span class="n">roi_names</span><span class="p">,</span>
            <span class="s1">&#39;roi_desc&#39;</span><span class="p">:</span> <span class="n">roi_desc</span><span class="p">,</span>
            <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="n">labels</span>
        <span class="p">},</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span> <span class="nf">get_tile_roi_mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">loc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
        <span class="n">roi_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the ROI mask for a tile at the given location.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            grid (tuple[int, int], optional): Grid indices of the tile.</span>
<span class="sd">                Must supply either ``grid`` or ``loc``. Defaults to None.</span>
<span class="sd">            loc (tuple[int, int], optional): Location of the tile center.</span>
<span class="sd">                Must supply either ``grid`` or ``loc``. Defaults to None.</span>
<span class="sd">            mode (str, optional): &#39;binary&#39;, &#39;multiclass&#39;, or &#39;multilabel&#39;.</span>
<span class="sd">                Defaults to &#39;binary&#39;.</span>
<span class="sd">            roi_labels (list[str], optional): List of ROI labels to include.</span>
<span class="sd">                Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: ROI mask for the tile, with dtype int and shape</span>
<span class="sd">                (n, tile_px, tile_px), where n is the number of ROI labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">loc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Either grid or loc must be provided.&quot;</span><span class="p">)</span>

        <span class="c1"># Definitions.</span>
        <span class="n">fe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_stride</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span> <span class="o">/</span> <span class="n">fe</span>

        <span class="c1"># Get the polygon vertices for the tile.</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Convert from grid to top-left coordinates</span>
            <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">=</span> <span class="n">grid</span>
            <span class="n">topleft</span> <span class="o">=</span> <span class="p">(</span><span class="n">gx</span> <span class="o">*</span> <span class="n">fs</span><span class="p">,</span> <span class="n">gy</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
            <span class="n">bottomleft</span> <span class="o">=</span> <span class="p">(</span><span class="n">gx</span> <span class="o">*</span> <span class="n">fs</span><span class="p">,</span> <span class="p">(</span><span class="n">gy</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span> <span class="o">+</span> <span class="n">fe</span><span class="p">)</span>
            <span class="n">bottomright</span> <span class="o">=</span> <span class="p">((</span><span class="n">gx</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span> <span class="o">+</span> <span class="n">fe</span><span class="p">,</span> <span class="p">(</span><span class="n">gy</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span> <span class="o">+</span> <span class="n">fe</span><span class="p">)</span>
            <span class="n">topright</span> <span class="o">=</span> <span class="p">((</span><span class="n">gx</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span> <span class="o">+</span> <span class="n">fe</span><span class="p">,</span> <span class="n">gy</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Convert from center to top-left coordinates</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">loc</span>
            <span class="n">cx</span> <span class="o">-=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fe</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">cy</span> <span class="o">-=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fe</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">topleft</span> <span class="o">=</span> <span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span>
            <span class="n">bottomleft</span> <span class="o">=</span> <span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">+</span> <span class="n">fe</span><span class="p">)</span>
            <span class="n">bottomright</span> <span class="o">=</span> <span class="p">(</span><span class="n">cx</span> <span class="o">+</span> <span class="n">fe</span><span class="p">,</span> <span class="n">cy</span> <span class="o">+</span> <span class="n">fe</span><span class="p">)</span>
            <span class="n">topright</span> <span class="o">=</span> <span class="p">(</span><span class="n">cx</span> <span class="o">+</span> <span class="n">fe</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span>

        <span class="c1"># Get a polygon for the tile, used for determining overlapping ROIs.</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([</span><span class="n">topleft</span><span class="p">,</span> <span class="n">bottomleft</span><span class="p">,</span> <span class="n">bottomright</span><span class="p">,</span> <span class="n">topright</span><span class="p">])</span>

        <span class="c1"># Compute the mask from ROIs.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">roi_labels</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">roi_labels</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Handle ROIs with labels (multilabel or multiclass)</span>
        <span class="k">elif</span> <span class="n">roi_labels</span><span class="p">:</span>
            <span class="n">labeled_masks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">roi_labels</span><span class="p">:</span>
                <span class="n">wsi_polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">poly</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">label</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wsi_polys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                    <span class="n">labeled_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">all_polys</span> <span class="o">=</span> <span class="n">unary_union</span><span class="p">(</span><span class="n">wsi_polys</span><span class="p">)</span>
                    <span class="n">polys</span> <span class="o">=</span> <span class="n">get_scaled_and_intersecting_polys</span><span class="p">(</span>
                        <span class="n">all_polys</span><span class="p">,</span> <span class="n">tile</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">topleft</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="n">sg</span><span class="o">.</span><span class="n">Polygon</span><span class="p">)</span> <span class="ow">and</span> <span class="n">polys</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Rasterize to an int mask.</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span>
                            <span class="p">[</span><span class="n">polys</span><span class="p">],</span>
                            <span class="n">out_shape</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                    <span class="n">labeled_masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">labeled_masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Handle ROIs without labels (binary)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Determine the intersection at the given tile location.</span>
            <span class="n">all_polys</span> <span class="o">=</span> <span class="n">unary_union</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">poly</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">])</span>
            <span class="n">polys</span> <span class="o">=</span> <span class="n">get_scaled_and_intersecting_polys</span><span class="p">(</span>
                <span class="n">all_polys</span><span class="p">,</span> <span class="n">tile</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">topleft</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="n">sg</span><span class="o">.</span><span class="n">Polygon</span><span class="p">)</span> <span class="ow">and</span> <span class="n">polys</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Rasterize to an int mask.</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">features</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">polys</span><span class="p">],</span>
                        <span class="n">out_shape</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1"># Add a dummy channel dimension.</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="c1"># Process according to the mode.</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;multiclass&#39;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;binary&#39;</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">has_non_roi_qc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the slide has any non-ROI QC masks.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">is_roi</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_masks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extract_tiles</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tfrecord_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tiles_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">img_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;jpg&#39;</span><span class="p">,</span>
        <span class="n">report</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SlideReport</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extracts tiles from slide using the build_generator() method,</span>
<span class="sd">        saving tiles into a TFRecord file or as loose JPG tiles in a directory.</span>

<span class="sd">        Args:</span>
<span class="sd">            tfrecord_dir (str): If provided, saves tiles into a TFRecord file</span>
<span class="sd">                (named according to slide name) here.</span>
<span class="sd">            tiles_dir (str): If provided, saves loose images in a subdirectory</span>
<span class="sd">                 (per slide name) here.</span>
<span class="sd">            img_format (str): &#39;png&#39; or &#39;jpg&#39;. Format of images for internal</span>
<span class="sd">                storage in tfrecords. PNG (lossless) format recommended for</span>
<span class="sd">                fidelity, JPG (lossy) for efficiency. Defaults to &#39;jpg&#39;.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            whitespace_fraction (float, optional): Range 0-1. Defaults to 1.</span>
<span class="sd">                Discard tiles with this fraction of whitespace. If 1, will not</span>
<span class="sd">                perform whitespace filtering.</span>
<span class="sd">            whitespace_threshold (int, optional): Range 0-255. Defaults to 230.</span>
<span class="sd">                Threshold above which a pixel (RGB average) is whitespace.</span>
<span class="sd">            grayspace_fraction (float, optional): Range 0-1. Defaults to 0.6.</span>
<span class="sd">                Discard tiles with this fraction of grayspace. If 1, will not</span>
<span class="sd">                perform grayspace filtering.</span>
<span class="sd">            grayspace_threshold (float, optional): Range 0-1. Defaults to 0.05.</span>
<span class="sd">                Pixels in HSV format with saturation below this threshold are</span>
<span class="sd">                considered grayspace.</span>
<span class="sd">            normalizer (str, optional): Normalization to use on image tiles.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            normalizer_source (str, optional): Stain normalization preset or</span>
<span class="sd">                path to a source image. Valid presets include &#39;v1&#39;, &#39;v2&#39;, and</span>
<span class="sd">                &#39;v3&#39;. If None, will use the default present (&#39;v3&#39;).</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            full_core (bool, optional): Extract an entire detected core, rather</span>
<span class="sd">                than subdividing into image tiles. Defaults to False.</span>
<span class="sd">            shuffle (bool): Shuffle images during extraction.</span>
<span class="sd">            num_threads (int): Number of threads to allocate to workers.</span>
<span class="sd">            yolo (bool, optional): Export yolo-formatted tile-level ROI</span>
<span class="sd">                annotations (.txt) in the tile directory. Requires that</span>
<span class="sd">                tiles_dir is set. Defaults to False.</span>
<span class="sd">            draw_roi (bool, optional): Draws ROIs onto extracted tiles.</span>
<span class="sd">                Defaults to False.</span>
<span class="sd">            dry_run (bool, optional): Determine tiles that would be extracted,</span>
<span class="sd">                but do not export any images. Defaults to None.</span>
<span class="sd">            num_threads (int): If specified, will extract tiles with a</span>
<span class="sd">                ThreadPool using the specified number of threads. Cannot</span>
<span class="sd">                supply both `num_threads` and `num_processes`. Libvips is</span>
<span class="sd">                particularly slow with ThreadPools. Defaults to None in the</span>
<span class="sd">                Libvips backend, and the number of CPU cores when using cuCIM.</span>
<span class="sd">            num_processes (int): If specified, will extract tiles with a</span>
<span class="sd">                multiprocessing pool using the specified number of processes.</span>
<span class="sd">                Cannot supply both `num_threads` and `num_processes`.</span>
<span class="sd">                With the libvips backend, this defaults to half the number of</span>
<span class="sd">                CPU cores, and with cuCIM, this defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">img_format</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;png&#39;</span><span class="p">,</span> <span class="s1">&#39;jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;jpeg&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid image format </span><span class="si">{</span><span class="n">img_format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">dry_run</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dry_run&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;dry_run&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="c1"># Make base directories</span>
        <span class="k">if</span> <span class="n">tfrecord_dir</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dry_run</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">exists</span><span class="p">(</span><span class="n">tfrecord_dir</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">tfrecord_dir</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tiles_dir</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dry_run</span><span class="p">:</span>
            <span class="n">tiles_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tiles_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">tiles_dir</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">tiles_dir</span><span class="p">)</span>

        <span class="c1"># Log to keep track of when tiles have finished extracting</span>
        <span class="c1"># To be used in case tile extraction is interrupted, so the slide</span>
        <span class="c1"># can be flagged for re-extraction</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tfrecord_dir</span> <span class="ow">or</span> <span class="n">tiles_dir</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dry_run</span><span class="p">:</span>
            <span class="n">unfinished_marker</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span>
                <span class="p">(</span><span class="n">tfrecord_dir</span> <span class="k">if</span> <span class="n">tfrecord_dir</span> <span class="k">else</span> <span class="n">tiles_dir</span><span class="p">),</span>  <span class="c1"># type: ignore</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.unfinished&#39;</span>
            <span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">unfinished_marker</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">marker_file</span><span class="p">:</span>
                <span class="n">marker_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tfrecord_dir</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dry_run</span><span class="p">:</span>
            <span class="n">writer</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">TFRecordWriter</span><span class="p">(</span><span class="n">join</span><span class="p">(</span>
                <span class="n">tfrecord_dir</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;.tfrecords&quot;</span>
            <span class="p">))</span>

        <span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_generator</span><span class="p">(</span>
            <span class="n">img_format</span><span class="o">=</span><span class="n">img_format</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">generator</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tfrecord_dir</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">tfrecord_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;.tfrecords&quot;</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">sample_tiles</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># type: List</span>
        <span class="n">generator_iterator</span> <span class="o">=</span> <span class="n">generator</span><span class="p">()</span>
        <span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">grid_locations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ws_fractions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">gs_fractions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">num_wrote_to_tfr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">slide_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">tile_dict</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">generator_iterator</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">location</span> <span class="o">=</span> <span class="n">tile_dict</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">]</span>
            <span class="n">locations</span> <span class="o">+=</span> <span class="p">[</span><span class="n">location</span><span class="p">]</span>
            <span class="n">grid_locations</span> <span class="o">+=</span> <span class="p">[</span><span class="n">tile_dict</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="s1">&#39;ws_fraction&#39;</span> <span class="ow">in</span> <span class="n">tile_dict</span><span class="p">:</span>
                <span class="n">ws_fractions</span> <span class="o">+=</span> <span class="p">[</span><span class="n">tile_dict</span><span class="p">[</span><span class="s1">&#39;ws_fraction&#39;</span><span class="p">]]</span>
            <span class="k">if</span> <span class="s1">&#39;gs_fraction&#39;</span> <span class="ow">in</span> <span class="n">tile_dict</span><span class="p">:</span>
                <span class="n">gs_fractions</span> <span class="o">+=</span> <span class="p">[</span><span class="n">tile_dict</span><span class="p">[</span><span class="s1">&#39;gs_fraction&#39;</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">dry_run</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">img_str</span> <span class="o">=</span> <span class="n">tile_dict</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_tiles</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">sample_tiles</span> <span class="o">+=</span> <span class="p">[</span><span class="n">img_str</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">tiles_dir</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tfrecord_dir</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dry_run</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">tiles_dir</span><span class="p">:</span>
                <span class="n">img_f</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span>
                    <span class="n">tiles_dir</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shortname</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">img_format</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">img_f</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
                    <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">img_str</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;yolo&#39;</span> <span class="ow">in</span> <span class="n">tile_dict</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tile_dict</span><span class="p">[</span><span class="s1">&#39;yolo&#39;</span><span class="p">]):</span>
                    <span class="n">yolo_f</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">tiles_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shortname</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">-</span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s1">.txt&#39;</span><span class="p">)</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">yolo_f</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outfile</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">tile_dict</span><span class="p">[</span><span class="s1">&#39;yolo&#39;</span><span class="p">]:</span>
                            <span class="n">yolo_str_fmt</span> <span class="o">=</span> <span class="s2">&quot;0 </span><span class="si">{:.3f}</span><span class="s2"> </span><span class="si">{:.3f}</span><span class="s2"> </span><span class="si">{:.3f}</span><span class="s2"> </span><span class="si">{:.3f}</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="n">outfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">yolo_str_fmt</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">ann</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="n">ann</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                <span class="n">ann</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                <span class="n">ann</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                            <span class="p">))</span>
            <span class="k">if</span> <span class="n">tfrecord_dir</span><span class="p">:</span>
                <span class="n">record</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">serialized_record</span><span class="p">(</span><span class="n">slide_bytes</span><span class="p">,</span> <span class="n">img_str</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
                <span class="n">num_wrote_to_tfr</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">tfrecord_dir</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dry_run</span><span class="p">:</span>
            <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">num_wrote_to_tfr</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">tfrecord_dir</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;.tfrecords&quot;</span><span class="p">))</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No tiles extracted for [green]</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">generator_iterator</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tfrecord_dir</span> <span class="ow">or</span> <span class="n">tiles_dir</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dry_run</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">unfinished_marker</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to mark slide </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> as complete&quot;</span><span class="p">)</span>

        <span class="c1"># Generate extraction report</span>
        <span class="k">if</span> <span class="n">report</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Generating slide report&quot;</span><span class="p">)</span>
            <span class="n">loc_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">locations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">grid_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid_locations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">df_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;loc_x&#39;</span><span class="p">:</span> <span class="p">[]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_np</span><span class="p">)</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">loc_np</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                <span class="s1">&#39;loc_y&#39;</span><span class="p">:</span> <span class="p">[]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">loc_np</span><span class="p">)</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">loc_np</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                <span class="s1">&#39;grid_x&#39;</span><span class="p">:</span> <span class="p">[]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_np</span><span class="p">)</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">grid_np</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                <span class="s1">&#39;grid_y&#39;</span><span class="p">:</span> <span class="p">[]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_np</span><span class="p">)</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">grid_np</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">ws_fractions</span><span class="p">:</span>
                <span class="n">df_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;ws_fraction&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">ws_fractions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)})</span>
            <span class="k">if</span> <span class="n">gs_fractions</span><span class="p">:</span>
                <span class="n">df_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;gs_fraction&#39;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">gs_fractions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)})</span>
            <span class="n">report_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">blur_burden</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">blur_burden</span><span class="p">,</span>
                <span class="n">num_tiles</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">locations</span><span class="p">),</span>
                <span class="n">qc_mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qc_mask</span><span class="p">,</span>
                <span class="n">locations</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">df_dict</span><span class="p">),</span>
                <span class="n">num_rois</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">==</span> <span class="s1">&#39;ignore&#39;</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">)),</span>
                <span class="n">tile_px</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span>
                <span class="n">tile_um</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_um</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">slide_report</span> <span class="o">=</span> <span class="n">SlideReport</span><span class="p">(</span>
                <span class="n">sample_tiles</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">report_data</span><span class="p">,</span>
                <span class="n">thumb_coords</span><span class="o">=</span><span class="n">locations</span><span class="p">,</span>
                <span class="n">tile_px</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span>
                <span class="n">tile_um</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_um</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">slide_report</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Skipping slide report&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">extract_cells</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tfrecord_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tiles_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">img_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;jpg&#39;</span><span class="p">,</span>
        <span class="n">report</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">apply_masks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SlideReport</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract tiles from cell segmentation centroids.</span>

<span class="sd">        Args:</span>
<span class="sd">            tfrecord_dir (str): If provided, saves tiles into a TFRecord file</span>
<span class="sd">                (named according to slide name) here.</span>
<span class="sd">            tiles_dir (str): If provided, saves loose images into a</span>
<span class="sd">                subdirectory (per slide name) here.</span>
<span class="sd">            img_format (str): &#39;png&#39; or &#39;jpg&#39;. Format of images for internal</span>
<span class="sd">                storage in tfrecords. PNG (lossless) format recommended for</span>
<span class="sd">                fidelity, JPG (lossy) for efficiency. Defaults to &#39;jpg&#39;.</span>
<span class="sd">            report (bool): Generate and return PDF report of tile extraction.</span>
<span class="sd">            apply_masks (bool): Apply cell segmentation masks to the extracted</span>
<span class="sd">                tiles. Defaults to True.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            **kwargs: All keyword arguments are passed to :meth:`WSI.extract_tiles()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">segmentation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot build generator from segmentation centroids; &quot;</span>
                <span class="s2">&quot;segmentation not yet applied. Use WSI.apply_segmentation().&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_tiles</span><span class="p">(</span>
            <span class="n">tfrecord_dir</span><span class="p">,</span>
            <span class="n">tiles_dir</span><span class="p">,</span>
            <span class="n">img_format</span><span class="p">,</span>
            <span class="n">report</span><span class="p">,</span>
            <span class="n">apply_masks</span><span class="o">=</span><span class="n">apply_masks</span><span class="p">,</span>
            <span class="n">from_centroids</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_tile_roi</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">coord</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the ROI that contains a given tile.</span>

<span class="sd">        Args:</span>
<span class="sd">            coord (Tuple[int, int], optional): Base-level coordinates of the</span>
<span class="sd">                tile. Cannot supply both ``coord`` and ``grid``. Defaults to None.</span>
<span class="sd">            grid (Tuple[int, int], optional): Grid index of the tile.</span>
<span class="sd">                Cannot supply both ``coord`` and ``grid``. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[int, ROI]: ROI index (index of WSI.rois) and</span>
<span class="sd">                the :class:`slideflow.slide.ROI` that contains the tile.</span>
<span class="sd">                If no ROI contains the tile, returns (None, None).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">grid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both coord and grid&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord_to_grid</span><span class="p">(</span><span class="o">*</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify either coord or grid&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="n">roi_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_grid</span><span class="p">[</span><span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">roi_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">roi_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">[</span><span class="n">roi_idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">grid_to_coord</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">grid_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">grid_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">anchor</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;center&#39;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the base-level coordinates of a tile by its grid index.</span>

<span class="sd">        Args:</span>
<span class="sd">            grid_x (int): x-index of the tile in the grid.</span>
<span class="sd">            grid_y (int): y-index of the tile in the grid.</span>

<span class="sd">        Keyword args:</span>
<span class="sd">            anchor (str): Anchor point for the coordinates. Either &#39;topleft&#39;</span>
<span class="sd">                or &#39;center&#39;. Defaults to &#39;center&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[int, int]: Base-level coordinates of the tile.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If anchor is not &#39;topleft&#39; or &#39;center&#39;.</span>
<span class="sd">            IndexError: If tile is not found at the given coordinates.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;topleft&#39;</span><span class="p">,</span> <span class="s1">&#39;center&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;anchor must be &#39;topleft&#39; or &#39;center&#39;&quot;</span><span class="p">)</span>
        <span class="n">grid_idx</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">grid_x</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">grid_y</span><span class="p">)</span>
        <span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_idx</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tile at grid=(</span><span class="si">{</span><span class="n">grid_x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">grid_y</span><span class="si">}</span><span class="s2">) not found&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid_x</span><span class="p">,</span> <span class="n">grid_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">[</span><span class="n">grid_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">anchor</span> <span class="o">==</span> <span class="s1">&#39;center&#39;</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="k">def</span> <span class="nf">get_tile_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">sparse_mask</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a mask for a tile, given a sparse mask.</span>

<span class="sd">        Examples</span>
<span class="sd">            Get a mask for a tile, given a sparse mask.</span>

<span class="sd">                &gt;&gt;&gt; from slideflow.cellseg import seg_utils, Segmentation</span>
<span class="sd">                &gt;&gt;&gt; segmentation = Segmentation(...)</span>
<span class="sd">                &gt;&gt;&gt; wsi = sf.WSI(...)</span>
<span class="sd">                &gt;&gt;&gt; wsi.apply_segmentation(segmentation)</span>
<span class="sd">                &gt;&gt;&gt; sparse_mask = seg_utils.sparse_mask(segmentation.masks)</span>
<span class="sd">                &gt;&gt;&gt; wsi.get_tile_mask(0, sparse_mask)</span>
<span class="sd">                &lt;numpy.ndarray&gt;</span>

<span class="sd">        Args:</span>
<span class="sd">            index (int): Index of tile.</span>
<span class="sd">            sparse_mask (scipy.sparse.csr_matrix): Sparse mask.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Mask for tile.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the corresponding segmentation mask, reading from the sparse matrix</span>
        <span class="n">seg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segmentation</span>
        <span class="k">if</span> <span class="n">seg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Segmentation not yet applied to slide.&quot;</span><span class="p">)</span>
        <span class="n">mask_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_coord</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># sparse mask index starts at 1</span>
        <span class="n">mask_y</span><span class="p">,</span> <span class="n">mask_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">sparse_mask</span><span class="p">[</span><span class="n">mask_idx</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">masks</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># This is the top-left coordinate, in WSI base dimension,</span>
        <span class="c1"># of the tile extraction window.</span>
        <span class="n">wsi_tile_top_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_coord</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Determine the mask array offset (top-left), in mask coordinate space.</span>
        <span class="n">wsi_mask_x_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">wsi_offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">seg</span><span class="o">.</span><span class="n">wsi_ratio</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">wsi_mask_y_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">wsi_offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">seg</span><span class="o">.</span><span class="n">wsi_ratio</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Offset the mask to reflect WSI space (but still in mask coordinates).</span>
        <span class="n">wsi_mask_x</span> <span class="o">=</span> <span class="n">mask_x</span> <span class="o">+</span> <span class="n">wsi_mask_x_offset</span>
        <span class="n">wsi_mask_y</span> <span class="o">=</span> <span class="n">mask_y</span> <span class="o">+</span> <span class="n">wsi_mask_y_offset</span>

        <span class="c1"># Determine the tile window offset (top-left), in mask coordinate space.</span>
        <span class="n">tile_offset_x_in_mask_space</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">wsi_tile_top_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">seg</span><span class="o">.</span><span class="n">wsi_ratio</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">tile_offset_y_in_mask_space</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">wsi_tile_top_left</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">seg</span><span class="o">.</span><span class="n">wsi_ratio</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Adjust the mask coordinate space, using the tile window offset as origin.</span>
        <span class="n">tile_mask_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">wsi_mask_x</span> <span class="o">-</span> <span class="n">tile_offset_x_in_mask_space</span><span class="p">)</span>
        <span class="n">tile_mask_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">wsi_mask_y</span> <span class="o">-</span> <span class="n">tile_offset_y_in_mask_space</span><span class="p">)</span>

        <span class="c1"># Calculate the size of the tile window, in mask coordinate space.</span>
        <span class="n">mask_tile_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span> <span class="o">/</span> <span class="n">seg</span><span class="o">.</span><span class="n">wsi_ratio</span><span class="p">)</span>

        <span class="c1"># Clip the mask to the tile window view.</span>
        <span class="n">tile_mask_x</span> <span class="o">=</span> <span class="n">tile_mask_x</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask_tile_size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tile_mask_y</span> <span class="o">=</span> <span class="n">tile_mask_y</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask_tile_size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Convert mask coordinates (in sparse format) to 2D array.</span>
        <span class="n">unsized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mask_tile_size</span><span class="p">,</span> <span class="n">mask_tile_size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">unsized</span><span class="p">[</span><span class="n">tile_mask_y</span><span class="p">,</span> <span class="n">tile_mask_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Resize mask from mask coordinates to tile extraction WSI coordinates.</span>
        <span class="k">return</span> <span class="n">unsized</span>

    <span class="k">def</span> <span class="nf">has_rois</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if the slide has loaded ROIs and they are not being ignored.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">!=</span> <span class="s1">&#39;ignore&#39;</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_next_roi_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the next available name for an ROI.&quot;&quot;&quot;</span>
        <span class="n">existing</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">:])</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ROI_&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">r</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="n">hole_ids</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">hole</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">:])</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">holes</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">hole</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ROI_&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hole</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="n">existing</span> <span class="o">+=</span> <span class="n">hole_ids</span>
        <span class="n">roi_id</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">existing</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">existing</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;ROI_</span><span class="si">{</span><span class="n">roi_id</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">name</span>

    <span class="k">def</span> <span class="nf">load_roi_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">process</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_errors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">simplify_tolerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load an ROI from a numpy array.</span>

<span class="sd">        Args:</span>
<span class="sd">            array (np.ndarray): Array of shape (n_points, 2) containing</span>
<span class="sd">                the coordinates of the ROI shape, in base (level=0) dimension.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            process (bool): Process ROIs after loading. Defaults to True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_roi_name</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">roi</span> <span class="o">=</span> <span class="n">ROI</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">errors</span><span class="o">.</span><span class="n">InvalidROIError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">allow_errors</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Unable to load ROI: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>
        <span class="k">if</span> <span class="n">simplify_tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roi</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">simplify_tolerance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">=</span> <span class="s1">&#39;inside&#39;</span>
        <span class="k">if</span> <span class="n">process</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_rois</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_roi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_roi</span> <span class="o">==</span> <span class="n">roi</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">_roi</span><span class="o">.</span><span class="n">holes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">hole</span> <span class="o">==</span> <span class="n">roi</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">load_csv_roi</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">process</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">skip_invalid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">simplify_tolerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load ROIs from a CSV file.</span>

<span class="sd">        CSV file must contain headers &#39;ROI_name&#39;, &#39;X_base&#39;, and &#39;Y_base&#39;.</span>

<span class="sd">        Any previously loaded ROIs are cleared prior to loading.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str): Path to CSV file.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            process (bool): Process ROIs after loading. Defaults to True.</span>
<span class="sd">            scale (int): Scale factor to apply to ROI coordinates. Defaults to 1.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Clear any previously loaded ROIs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rois</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">roi_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csvfile</span><span class="p">:</span>
            <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">csvfile</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">headers</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">headers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span>
                <span class="n">headers</span> <span class="o">=</span> <span class="p">[</span><span class="n">h</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">headers</span><span class="p">]</span>
                <span class="n">index_name</span> <span class="o">=</span> <span class="n">headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;roi_name&quot;</span><span class="p">)</span>
                <span class="n">index_x</span> <span class="o">=</span> <span class="n">headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;x_base&quot;</span><span class="p">)</span>
                <span class="n">index_y</span> <span class="o">=</span> <span class="n">headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;y_base&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">ROIError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Unable to read CSV ROI [green]</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s1">[/]. Please ensure &#39;</span>
                    <span class="s1">&#39;headers contain &quot;ROI_name&quot;, &quot;X_base and &quot;Y_base&quot;.&#39;</span>
                <span class="p">)</span>
            <span class="n">index_label</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;label&quot;</span> <span class="ow">in</span> <span class="n">headers</span> <span class="k">else</span> <span class="n">headers</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
                <span class="n">roi_name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">index_name</span><span class="p">]</span>
                <span class="n">x_coord</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">index_x</span><span class="p">])</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>
                <span class="n">y_coord</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">index_y</span><span class="p">])</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>
                <span class="n">label</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">index_label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">row</span><span class="p">[</span><span class="n">index_label</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">roi_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">roi_dict</span><span class="p">:</span>
                    <span class="n">roi_dict</span><span class="p">[</span><span class="n">roi_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;coords&#39;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="n">label</span>
                    <span class="p">}</span>
                <span class="n">roi_dict</span><span class="p">[</span><span class="n">roi_name</span><span class="p">][</span><span class="s1">&#39;coords&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">roi_name</span> <span class="ow">in</span> <span class="n">roi_dict</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">roi</span> <span class="o">=</span> <span class="n">ROI</span><span class="p">(</span>
                        <span class="n">roi_name</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">roi_dict</span><span class="p">[</span><span class="n">roi_name</span><span class="p">][</span><span class="s1">&#39;coords&#39;</span><span class="p">]),</span>
                        <span class="n">label</span><span class="o">=</span><span class="n">roi_dict</span><span class="p">[</span><span class="n">roi_name</span><span class="p">][</span><span class="s1">&#39;label&#39;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="n">errors</span><span class="o">.</span><span class="n">InvalidROIError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">skip_invalid</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Skipping invalid ROI (</span><span class="si">{}</span><span class="s2">): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">roi_name</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">simplify_tolerance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">roi</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">simplify_tolerance</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">process</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_rois</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded ROIs from </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load_json_roi</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">process</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">skip_invalid</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load ROIs from a JSON file.</span>

<span class="sd">        JSON file must contain a &#39;shapes&#39; key, with a list of dictionaries</span>
<span class="sd">        containing a &#39;points&#39; key, whose value is a list of (x, y) coordinates.</span>

<span class="sd">        Args:</span>
<span class="sd">            path (str): Path to JSON file.</span>
<span class="sd">            scale (int): Scale factor to apply to ROI coordinates. Defaults to 1.</span>
<span class="sd">            process (bool): Process ROIs after loading. Defaults to True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Clear any previously loaded ROIs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rois</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">json_file</span><span class="p">:</span>
            <span class="n">json_data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">json_file</span><span class="p">)[</span><span class="s1">&#39;shapes&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">json_data</span><span class="p">:</span>
            <span class="n">area_reduced</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">],</span> <span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">roi_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_roi_name</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ROI</span><span class="p">(</span><span class="n">roi_name</span><span class="p">,</span> <span class="n">area_reduced</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">errors</span><span class="o">.</span><span class="n">InvalidROIError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">skip_invalid</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Skipping invalid ROI (</span><span class="si">{}</span><span class="s2">): </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">roi_name</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">process</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_rois</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">=</span> <span class="s1">&#39;inside&#39;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">masked_thumb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">background</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a masked thumbnail of a slide, using QC and/or ROI masks.</span>

<span class="sd">        Args:</span>
<span class="sd">            background (str, optional): Background color. Defaults to &#39;white&#39;.</span>

<span class="sd">        Keyword args:</span>
<span class="sd">            **kwargs: Keyword arguments passed to :meth:`WSI.thumb()`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Masked thumbnail image.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">background</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="s1">&#39;black&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected background option: &#39;</span><span class="si">{</span><span class="n">background</span><span class="si">}</span><span class="s2">&#39;. Expected &quot;</span>
                <span class="s2">&quot;&#39;black&#39; or &#39;white&#39;.&quot;</span>
            <span class="p">)</span>
        <span class="n">qc_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_mask</span>
        <span class="n">roi_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_mask</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thumb</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">qc_mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">roi_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Apply Otsu&#39;s threshold to background area</span>
            <span class="c1"># to prevent whitespace from interfering with normalization</span>
            <span class="kn">from</span> <span class="nn">slideflow.slide.qc</span> <span class="kn">import</span> <span class="n">Otsu</span><span class="p">,</span> <span class="n">GaussianV2</span>
            <span class="n">sf</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Applying Otsu&#39;s thresholding &amp; Gaussian blur filter &quot;</span>
                <span class="s2">&quot;to stain norm context&quot;</span>
            <span class="p">)</span>
            <span class="n">_blur_mask</span> <span class="o">=</span> <span class="n">GaussianV2</span><span class="p">()(</span><span class="n">image</span><span class="p">)</span>
            <span class="n">qc_mask</span> <span class="o">=</span> <span class="n">Otsu</span><span class="p">()(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_blur_mask</span><span class="p">)</span>
        <span class="c1"># Mask by ROI and QC, if applied.</span>
        <span class="c1"># Use white as background for masked areas.</span>
        <span class="k">if</span> <span class="n">qc_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qc_img</span> <span class="o">=</span> <span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">qc_mask</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">qc_img</span><span class="p">,</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">roi_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roi_img</span> <span class="o">=</span> <span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">roi_mask</span><span class="p">)</span>
            <span class="n">roi_mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">roi_img</span><span class="p">,</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">qc_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">roi_mask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">roi_mask</span>
        <span class="k">if</span> <span class="n">background</span> <span class="o">==</span> <span class="s1">&#39;white&#39;</span><span class="p">:</span>
            <span class="n">white_bg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">white_mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">white_bg</span><span class="p">,</span> <span class="n">white_bg</span><span class="p">,</span> <span class="n">mask</span><span class="o">=~</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">white_mask</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cv2</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mpp_to_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mpp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">mpp</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">mpp</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a whole-slide prediction from a saved model.</span>

<span class="sd">        Args:</span>
<span class="sd">            model (str): Path to saved model trained in Slideflow.</span>

<span class="sd">        Keyword args:</span>
<span class="sd">            batch_size (int, optional): Batch size for calculating predictions.</span>
<span class="sd">                Defaults to 32.</span>
<span class="sd">            num_threads (int, optional): Number of tile worker threads. Cannot</span>
<span class="sd">                supply both ``num_threads`` (uses thread pool) and</span>
<span class="sd">                ``num_processes`` (uses multiprocessing pool). Defaults to</span>
<span class="sd">                CPU core count.</span>
<span class="sd">            num_processes (int, optional): Number of child processes to spawn</span>
<span class="sd">                for multiprocessing pool. Defaults to None (does not use</span>
<span class="sd">                multiprocessing).</span>
<span class="sd">            img_format (str, optional): Image format (png, jpg) to use when</span>
<span class="sd">                extracting tiles from slide. Must match the image format</span>
<span class="sd">                the model was trained on. If &#39;auto&#39;, will use the format</span>
<span class="sd">                logged in the model params.json. Defaults to &#39;auto&#39;.</span>
<span class="sd">            device (torch.device, optional): PyTorch device. Defaults to</span>
<span class="sd">                initializing a new CUDA device.</span>
<span class="sd">            generator_kwargs (dict, optional): Keyword arguments passed to</span>
<span class="sd">                the :meth:`slideflow.WSI.build_generator()`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Predictions for each outcome, with shape = (num_classes, )</span>

<span class="sd">            np.ndarray, optional: Uncertainty for each outcome, if the model was</span>
<span class="sd">            trained with uncertainty, with shape = (num_classes,)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">slideflow</span> <span class="kn">import</span> <span class="n">Heatmap</span>

        <span class="n">config</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">get_model_config</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="n">_compatible</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">is_tile_size_compatible</span><span class="p">(</span>
            <span class="n">config</span><span class="p">[</span><span class="s1">&#39;tile_px&#39;</span><span class="p">],</span>
            <span class="n">config</span><span class="p">[</span><span class="s1">&#39;tile_um&#39;</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tile_um</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_compatible</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">IncompatibleTileSizeError</span><span class="p">(</span>
                <span class="s2">&quot;Slide tile size (tile_px=</span><span class="si">{}</span><span class="s2">, tile_um=</span><span class="si">{}</span><span class="s2">) does not match the &quot;</span>
                <span class="s2">&quot;model (tile_px=</span><span class="si">{}</span><span class="s2">, tile_um=</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_um</span><span class="p">,</span>
                    <span class="n">config</span><span class="p">[</span><span class="s1">&#39;tile_px&#39;</span><span class="p">],</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;tile_um&#39;</span><span class="p">]</span>
            <span class="p">))</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating whole-slide prediction...&quot;</span><span class="p">)</span>
        <span class="n">heatmap</span> <span class="o">=</span> <span class="n">Heatmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">generate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">heatmap</span><span class="o">.</span><span class="n">predictions</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">heatmap</span><span class="o">.</span><span class="n">predictions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">heatmap</span><span class="o">.</span><span class="n">uncertainty</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">unc</span> <span class="o">=</span> <span class="n">heatmap</span><span class="o">.</span><span class="n">uncertainty</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">heatmap</span><span class="o">.</span><span class="n">uncertainty</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">unc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">unc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">preds</span><span class="p">,</span> <span class="n">unc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">preds</span>

    <span class="k">def</span> <span class="nf">preview</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rois</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">thumb_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">low_res</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Performs a dry run of tile extraction without saving any images,</span>
<span class="sd">        returning a PIL image of the slide thumbnail annotated with a grid of</span>
<span class="sd">        tiles that were marked for extraction.</span>

<span class="sd">        Args:</span>
<span class="sd">            rois (bool, optional): Draw ROI annotation(s) onto the image.</span>
<span class="sd">                Defaults to True.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            whitespace_fraction (float, optional): Range 0-1. Defaults to 1.</span>
<span class="sd">                Discard tiles with this fraction of whitespace. If 1, will not</span>
<span class="sd">                perform whitespace filtering.</span>
<span class="sd">            whitespace_threshold (int, optional): Range 0-255. Defaults to 230.</span>
<span class="sd">                Threshold above which a pixel (RGB average) is considered</span>
<span class="sd">                whitespace.</span>
<span class="sd">            grayspace_fraction (float, optional): Range 0-1. Defaults to 0.6.</span>
<span class="sd">                Discard tiles with this fraction of grayspace. If 1, will not</span>
<span class="sd">                perform grayspace filtering.</span>
<span class="sd">            grayspace_threshold (float, optional): Range 0-1. Defaults to 0.05.</span>
<span class="sd">                Pixels in HSV format with saturation below this threshold are</span>
<span class="sd">                considered grayspace.</span>
<span class="sd">            full_core (bool, optional): Extract an entire detected core, rather</span>
<span class="sd">                than subdividing into image tiles. Defaults to False.</span>
<span class="sd">            num_threads (int): Number of threads to allocate to workers.</span>
<span class="sd">            yolo (bool, optional): Export yolo-formatted tile-level ROI</span>
<span class="sd">                annotations (.txt) in the tile directory. Requires that</span>
<span class="sd">                tiles_dir is set. Defaults to False.</span>
<span class="sd">            thumb_kwargs (Optional[Dict], optional): Keyword arguments to pass</span>
<span class="sd">                to the thumb method. Defaults to None.</span>
<span class="sd">            low_res (bool, optional): Use low resolution thumbnail. Defaults to</span>
<span class="sd">                True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;show_progress&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;show_progress&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_generator</span><span class="p">(</span>
            <span class="n">dry_run</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">thumb_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">thumb_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">low_res</span><span class="o">=</span><span class="n">low_res</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">generator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">thumb</span><span class="p">(</span><span class="n">rois</span><span class="o">=</span><span class="n">rois</span><span class="p">,</span>  <span class="o">**</span><span class="n">thumb_kwargs</span><span class="p">)</span>
        <span class="n">locations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tile_dict</span> <span class="ow">in</span> <span class="n">generator</span><span class="p">():</span>
            <span class="n">locations</span> <span class="o">+=</span> <span class="p">[</span><span class="n">tile_dict</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">]]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Previewing with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span><span class="si">}</span><span class="s2"> extracted tile locations.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">thumb</span><span class="p">(</span>
            <span class="n">coords</span><span class="o">=</span><span class="n">locations</span><span class="p">,</span> <span class="n">rois</span><span class="o">=</span><span class="n">rois</span><span class="p">,</span> <span class="o">**</span><span class="n">thumb_kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_rois</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process loaded ROIs and apply to the slide grid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Number of ROIs processed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load annotations as shapely.geometry objects.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">roi_method</span> <span class="o">!=</span> <span class="s1">&#39;ignore&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_find_and_process_holes</span><span class="p">()</span>

        <span class="c1"># Regenerate the grid to reflect the newly-loaded ROIs.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_coord</span><span class="p">()</span>

        <span class="c1"># Re-apply any existing QC mask, now that the coordinates have changed.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_non_roi_qc</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_qc_mask</span><span class="p">()</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_and_process_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find and process holes in ROIs.&quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">shapely.strtree</span> <span class="kn">import</span> <span class="n">STRtree</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">poly</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">outer_rois</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">roi</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">roi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>

            <span class="n">rois</span> <span class="o">=</span> <span class="p">[</span><span class="n">roi</span> <span class="k">for</span> <span class="n">roi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span> <span class="k">if</span> <span class="n">roi</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">label</span><span class="p">]</span>
            <span class="n">polygons</span> <span class="o">=</span> <span class="p">[</span><span class="n">roi</span><span class="o">.</span><span class="n">poly</span> <span class="k">for</span> <span class="n">roi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span> <span class="k">if</span> <span class="n">roi</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">label</span><span class="p">]</span>
            <span class="n">strtree</span> <span class="o">=</span> <span class="n">STRtree</span><span class="p">(</span><span class="n">polygons</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">roi</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">polygons</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">shapely_version</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">version</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">&#39;2.0.0&#39;</span><span class="p">):</span>
                    <span class="n">possible_containers</span> <span class="o">=</span> <span class="n">strtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">possible_containers_idx</span> <span class="o">=</span> <span class="n">strtree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
                    <span class="n">possible_containers</span> <span class="o">=</span> <span class="p">[</span><span class="n">polygons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">possible_containers_idx</span><span class="p">]</span>

                <span class="c1"># Filter out the polygon itself</span>
                <span class="n">possible_containers</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">possible_containers</span> <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="n">poly</span><span class="p">]</span>

                <span class="c1"># Check if the polygon is contained by another</span>
                <span class="n">contained_by</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">possible_containers</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">poly</span><span class="p">)]</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">contained_by</span><span class="p">:</span>
                    <span class="c1"># Polygon is an outer polygon</span>
                    <span class="n">outer_rois</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Polygon is a hole, find its immediate outer polygon</span>
                    <span class="c1"># Sort by area (smallest to largest) to find the closets outer.</span>
                    <span class="n">contained_by</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>
                    <span class="n">immediate_outer_poly</span> <span class="o">=</span> <span class="n">contained_by</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">immediate_outer_roi</span> <span class="o">=</span> <span class="n">rois</span><span class="p">[</span><span class="n">polygons</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">immediate_outer_poly</span><span class="p">)]</span>

                    <span class="c1"># If the immediate outer is not already listed as an outer,</span>
                    <span class="c1"># then the immediate outer is a hole and this polygon is a nested</span>
                    <span class="c1"># polygon within a hole and should be treated as an outer.</span>
                    <span class="k">if</span> <span class="n">immediate_outer_roi</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outer_rois</span><span class="p">:</span>
                        <span class="n">outer_rois</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Otherwise, add the polygon to the immediate outer as a hole</span>
                        <span class="n">immediate_outer_roi</span><span class="o">.</span><span class="n">add_hole</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span>

        <span class="c1"># Restrict the ROIs to only outer polygons, which have now had the holes applied.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rois</span> <span class="o">=</span> <span class="n">outer_rois</span>

    <span class="k">def</span> <span class="nf">qc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Callable</span><span class="p">]],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">blur_radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">blur_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.02</span><span class="p">,</span>
        <span class="n">filter_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.6</span><span class="p">,</span>
        <span class="n">blur_mpp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pool</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;mp.pool.Pool&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies quality control to a slide, performing filtering based on</span>
<span class="sd">        a whole-slide image thumbnail.</span>

<span class="sd">        &#39;blur&#39; method filters out blurry or out-of-focus slide sections.</span>
<span class="sd">        &#39;otsu&#39; method filters out background based on automatic saturation</span>
<span class="sd">        thresholding in the HSV colorspace.</span>
<span class="sd">        &#39;both&#39; applies both methods of filtering.</span>

<span class="sd">        Args:</span>
<span class="sd">            method (str, Callable, list(Callable)): Quality control method(s).</span>
<span class="sd">                If a string, may be &#39;blur&#39;, &#39;otsu&#39;, or &#39;both&#39;.</span>
<span class="sd">                If a callable (or list of callables), each must accept a sf.WSI</span>
<span class="sd">                object and return a np.ndarray (dtype=np.bool).</span>
<span class="sd">            blur_radius (int, optional): Blur radius. Only used if method is</span>
<span class="sd">                &#39;blur&#39; or &#39;both&#39;.</span>
<span class="sd">            blur_threshold (float, optional): Blur threshold. Only used if</span>
<span class="sd">                method is &#39;blur&#39; or &#39;both.&#39;</span>
<span class="sd">            filter_threshold (float): Percent of a tile detected as</span>
<span class="sd">                background that will trigger a tile to be discarded.</span>
<span class="sd">                Defaults to 0.6.</span>
<span class="sd">            blur_mpp (float, optional): Size of WSI thumbnail on which to</span>
<span class="sd">                perform blur QC, in microns-per-pixel. Defaults to 4 times the</span>
<span class="sd">                tile extraction MPP (e.g. for a tile_px/tile_um combination</span>
<span class="sd">                at 10X effective magnification, where tile_px=tile_um, the</span>
<span class="sd">                default blur_mpp would be 4, or effective magnification 2.5x).</span>
<span class="sd">                Only used if method is &#39;blur&#39; or &#39;both&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Image: Image of applied QC mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Prepare known QC methods - &#39;blur&#39;, &#39;otsu&#39;, and &#39;both&#39;.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">method</span> <span class="o">=</span> <span class="p">[</span><span class="n">method</span><span class="p">]</span>           <span class="c1"># type: ignore</span>
        <span class="k">if</span> <span class="s1">&#39;both&#39;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">method</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>       <span class="c1"># type: ignore</span>
            <span class="n">method</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;otsu&#39;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="c1"># Blur should be performed before Otsu&#39;s thresholding</span>
            <span class="n">method</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;blur&#39;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">if</span> <span class="s1">&#39;blur&#39;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;blur&#39;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">method</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;blur&#39;</span><span class="p">)</span>       <span class="c1"># type: ignore</span>
            <span class="n">method</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">qc</span><span class="o">.</span><span class="n">GaussianV2</span><span class="p">(</span><span class="n">mpp</span><span class="o">=</span><span class="n">blur_mpp</span><span class="p">,</span>
                                                      <span class="n">sigma</span><span class="o">=</span><span class="n">blur_radius</span><span class="p">,</span>
                                                      <span class="n">threshold</span><span class="o">=</span><span class="n">blur_threshold</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;otsu&#39;</span> <span class="ow">in</span> <span class="n">method</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;otsu&#39;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">method</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;otsu&#39;</span><span class="p">)</span>       <span class="c1"># type: ignore</span>
            <span class="n">method</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">qc</span><span class="o">.</span><span class="n">Otsu</span><span class="p">())</span>

        <span class="n">starttime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Applying QC: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qc</span> <span class="ow">in</span> <span class="n">method</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">QCError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown QC method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pool</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">qc</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">pool</span>  <span class="c1"># type: ignore</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to set pool for QC method </span><span class="si">{</span><span class="n">qc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">qc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_qc_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">filter_threshold</span><span class="o">=</span><span class="n">filter_threshold</span><span class="p">)</span>
        <span class="n">dur</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(time: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">starttime</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">s)&#39;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;QC (</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s1">) complete for slide </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shortname</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">dur</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">img</span>

    <span class="k">def</span> <span class="nf">remove_qc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qc_masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_masks</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">is_roi</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_coord</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;QC removed from slide </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shortname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_roi_qc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove ROI-based QC from the slide.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qc_masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qc_masks</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">is_roi</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qc_masks</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apply_qc_mask</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">remove_roi</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">idx</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">process</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove an ROI from the slide.</span>

<span class="sd">        Args:</span>
<span class="sd">            idx (int, list(int)): Index or indices of the ROI(s) to remove.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            process (bool): Process ROIs after removing. Defaults to True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">process</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process_rois</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set_artifacts</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">artifact_labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set artifact labels for all ROIs in the slide.</span>

<span class="sd">        Rebuilds the ROI grid after setting the artifacts.</span>

<span class="sd">        Args:</span>
<span class="sd">            artifact_labels (str, list(str)): Artifact label(s) to set.</span>
<span class="sd">                ROIs with these labels will be marked as artifacts.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">artifact_labels</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">artifact_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">artifact_labels</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">artifact_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">artifact_labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Artifact labels must be strings.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">artifact_labels</span> <span class="o">=</span> <span class="n">artifact_labels</span> <span class="k">if</span> <span class="n">artifact_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process_rois</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">show_alignment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">slide</span><span class="p">:</span> <span class="s2">&quot;WSI&quot;</span><span class="p">,</span>
        <span class="n">mpp</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show aligned thumbnail of another slide.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slide</span><span class="p">,</span> <span class="n">WSI</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only align to another slide.&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate thumbnails for alignment.</span>
        <span class="n">our_thumb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thumb</span><span class="p">(</span><span class="n">mpp</span><span class="o">=</span><span class="n">mpp</span><span class="p">))</span>
        <span class="n">their_thumb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slide</span><span class="o">.</span><span class="n">thumb</span><span class="p">(</span><span class="n">mpp</span><span class="o">=</span><span class="n">mpp</span><span class="p">))</span>

        <span class="c1"># Return an image of a thumbnail of the given slide,</span>
        <span class="c1"># aligned to this slide.</span>
        <span class="k">return</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">align_image</span><span class="p">(</span><span class="n">their_thumb</span><span class="p">,</span> <span class="n">our_thumb</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">square_thumb</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">512</span><span class="p">,</span>
        <span class="n">use_associated_image</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Returns a square thumbnail of the slide, with black bar borders.</span>

<span class="sd">        Args:</span>
<span class="sd">            width (int): Width/height of thumbnail in pixels.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL image</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">thumb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thumb</span><span class="p">(</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">use_associated_image</span><span class="o">=</span><span class="n">use_associated_image</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="p">(</span><span class="n">thumb</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="n">thumb</span><span class="o">.</span><span class="n">height</span><span class="p">))</span>
        <span class="n">thumb</span> <span class="o">=</span> <span class="n">thumb</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
        <span class="n">square_thumb</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;RGB&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
        <span class="n">square_thumb</span><span class="o">.</span><span class="n">paste</span><span class="p">(</span><span class="n">thumb</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">width</span><span class="o">-</span><span class="n">height</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">square_thumb</span>

    <span class="k">def</span> <span class="nf">thumb</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mpp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">width</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">coords</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rect_linewidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">rect_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span>
        <span class="n">rois</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">linewidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;black&#39;</span><span class="p">,</span>
        <span class="n">use_associated_image</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">low_res</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="o">.</span><span class="n">Image</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a PIL Image of the slide thumbnail, with ROI overlay.</span>

<span class="sd">        Args:</span>
<span class="sd">            mpp (float, optional): Microns-per-pixel, used to determine</span>
<span class="sd">                thumbnail size.</span>
<span class="sd">            width (int, optional): Goal thumbnail width (alternative to mpp).</span>
<span class="sd">            coords (list(int), optional): List of tile extraction coordinates</span>
<span class="sd">                to show as rectangles on the thumbnail, in [(x_center,</span>
<span class="sd">                y_center), ...] format. Defaults to None.</span>
<span class="sd">            rois (bool, optional): Draw ROIs onto thumbnail. Defaults to False.</span>
<span class="sd">            linewidth (int, optional): Width of ROI line. Defaults to 2.</span>
<span class="sd">            color (str, optional): Color of ROI. Defaults to black.</span>
<span class="sd">            use_associated_image (bool): Use the associated thumbnail image</span>
<span class="sd">                in the slide, rather than reading from a pyramid layer.</span>
<span class="sd">            low_res (bool): Create thumbnail from the lowest-mangnification</span>
<span class="sd">                pyramid layer. Defaults to False.</span>

<span class="sd">        Returns:</span>
<span class="sd">            PIL image</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rois</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mpp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Either mpp or width must be given, but not both&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; (got mpp=</span><span class="si">{</span><span class="n">mpp</span><span class="si">}</span><span class="s2">, width=</span><span class="si">{</span><span class="n">width</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
            <span class="c1"># If no values provided, create thumbnail of width 1024</span>
            <span class="k">if</span> <span class="n">mpp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="mi">1024</span>
            <span class="k">if</span> <span class="n">mpp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">roi_scale</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                             <span class="o">/</span> <span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">mpp</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">roi_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">width</span>  <span class="c1"># type: ignore</span>

        <span class="c1"># If no values provided, create thumbnail of width 1024</span>
        <span class="k">if</span> <span class="n">mpp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="mi">1024</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mpp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Either mpp or width must be given, but not both&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; (got mpp=</span><span class="si">{</span><span class="n">mpp</span><span class="si">}</span><span class="s2">, width=</span><span class="si">{</span><span class="n">width</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Calculate goal width/height according to specified microns-per-pixel</span>
        <span class="k">if</span> <span class="n">mpp</span><span class="p">:</span>
            <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">mpp</span><span class="p">)</span>
        <span class="c1"># Otherwise, calculate approximate mpp based on provided width</span>
        <span class="c1"># (to generate proportional height)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">width</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">mpp</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">width</span>
        <span class="c1"># Calculate appropriate height</span>
        <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mpp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">mpp</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">use_associated_image</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Requesting thumbnail using associated image&quot;</span><span class="p">)</span>
            <span class="n">thumb_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">associated</span><span class="o">=</span><span class="s1">&#39;thumbnail&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">low_res</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Requesting thumbnail at level=</span><span class="si">{}</span><span class="s2">, width=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">level_count</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span>
            <span class="p">))</span>
            <span class="n">thumb_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">level_count</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">width</span>
            <span class="n">level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">best_level_for_downsample</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Requesting thumbnail at level=</span><span class="si">{}</span><span class="s2">, width=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">level</span><span class="p">,</span> <span class="n">width</span>
            <span class="p">))</span>
            <span class="n">thumb_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>

        <span class="n">np_thumb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">slide</span><span class="o">.</span><span class="n">thumbnail</span><span class="p">(</span><span class="o">**</span><span class="n">thumb_kw</span><span class="p">)</span>
        <span class="n">thumb</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">np_thumb</span><span class="p">)</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">coords</span><span class="p">:</span>
            <span class="n">draw</span> <span class="o">=</span> <span class="n">ImageDraw</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">thumb</span><span class="p">)</span>
            <span class="n">ratio</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">wh</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_extract_px</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">coords</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">ratio</span>  <span class="c1"># type: ignore</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">wh</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="n">wh</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">wh</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="n">wh</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
                <span class="n">draw</span><span class="o">.</span><span class="n">rectangle</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">outline</span><span class="o">=</span><span class="n">rect_color</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">rect_linewidth</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rois</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">):</span>
            <span class="n">draw</span> <span class="o">=</span> <span class="n">ImageDraw</span><span class="o">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">thumb</span><span class="p">)</span>
            <span class="n">roi_polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">scaled_poly</span><span class="p">(</span><span class="n">roi_scale</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">roi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rois</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">roi</span><span class="o">.</span><span class="n">holes</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">roi_polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole</span><span class="o">.</span><span class="n">scaled_poly</span><span class="p">(</span><span class="n">roi_scale</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">poly</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">roi_polys</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">poly</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">==</span> <span class="s1">&#39;Polygon&#39;</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span>
                    <span class="n">zipped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
                    <span class="n">draw</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">zipped</span><span class="p">,</span> <span class="n">joint</span><span class="o">=</span><span class="s1">&#39;curve&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">linewidth</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">poly</span><span class="o">.</span><span class="n">geom_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;MultiPolygon&#39;</span><span class="p">,</span> <span class="s1">&#39;GeometryCollection&#39;</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">is_empty</span> <span class="ow">or</span> <span class="n">part</span><span class="o">.</span><span class="n">geom_type</span> <span class="o">!=</span> <span class="s1">&#39;Polygon&#39;</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span>
                        <span class="n">zipped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))</span>
                        <span class="n">draw</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">zipped</span><span class="p">,</span> <span class="n">joint</span><span class="o">=</span><span class="s1">&#39;curve&#39;</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">linewidth</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sf</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to plot ROI </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, unknown geometry type: </span><span class="si">{</span><span class="n">poly</span><span class="o">.</span><span class="n">geom_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">thumb</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">thumb</span>

    <span class="k">def</span> <span class="nf">tensorflow</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;numpy&#39;</span><span class="p">,</span>
        <span class="n">incl_slidenames</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">incl_loc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Tensorflow Dataset which extractes tiles from this slide.</span>

<span class="sd">        Args:</span>
<span class="sd">            img_format (str, optional): Image format for returned image tiles.</span>
<span class="sd">                Options include &#39;png&#39;, &#39;jpg&#39;, and &#39;numpy&#39;. Defaults to &#39;numpy&#39;.</span>
<span class="sd">            incl_slidenames (bool, optional): Yield slide names for each</span>
<span class="sd">                image tile. Defaults to False.</span>
<span class="sd">            incl_loc (Optional[str], optional): Yield image tile location</span>
<span class="sd">                with each image tile. Options include True, &#39;coord&#39;, or &#39;grid&#39;.</span>
<span class="sd">                If True or &#39;coord&#39;, will return X/Y coordinates of the tile center</span>
<span class="sd">                in the slide&#39;s highest magnification layer. If &#39;grid&#39;, returns</span>
<span class="sd">                the grid indices for the tile. Defaults to None.</span>
<span class="sd">            shuffle (bool, optional): Shuffle image tiles. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tf.data.Dataset</span>

<span class="sd">        Yields:</span>
<span class="sd">            Iterator[Any]: Items yielded by the Dataset are in dictionary</span>
<span class="sd">            format, with the keys:</span>

<span class="sd">            &#39;image_raw&#39;:    Contains the image (jpg, png, or numpy)</span>
<span class="sd">            &#39;slide&#39;:        Slide name (if ``incl_slidenames=True``)</span>
<span class="sd">            &#39;loc_x&#39;         Image tile center x location (if ``incl_loc`` provided)</span>
<span class="sd">            &#39;loc_y&#39;         Image tile center y location (if ``incl_loc`` provided)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>

        <span class="k">def</span> <span class="nf">tile_generator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">image_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_generator</span><span class="p">(</span>
                <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span>
                <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">img_format</span><span class="o">=</span><span class="n">img_format</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">incl_slidenames</span> <span class="ow">or</span> <span class="n">incl_loc</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">to_return</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;image_raw&#39;</span><span class="p">:</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="n">incl_slidenames</span><span class="p">:</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;slide&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
                    <span class="k">if</span> <span class="n">incl_loc</span> <span class="o">==</span> <span class="s1">&#39;coord&#39;</span> <span class="ow">or</span> <span class="n">incl_loc</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;loc_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;loc_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">incl_loc</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;loc_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;loc_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">yield</span> <span class="n">to_return</span>

        <span class="c1"># Generate dataset from the generator</span>
        <span class="k">with</span> <span class="n">tf</span><span class="o">.</span><span class="n">name_scope</span><span class="p">(</span><span class="s1">&#39;dataset_input&#39;</span><span class="p">):</span>
            <span class="c1"># Signatures for imaging data</span>
            <span class="k">if</span> <span class="n">img_format</span> <span class="o">==</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span>
                <span class="n">image_sig</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span>
                    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_px</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">uint8</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">image_sig</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>

            <span class="c1"># Rest of the signatures</span>
            <span class="k">if</span> <span class="n">incl_slidenames</span> <span class="ow">or</span> <span class="n">incl_loc</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;image_raw&#39;</span><span class="p">:</span> <span class="n">image_sig</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">incl_slidenames</span><span class="p">:</span>
                    <span class="n">sig</span><span class="p">[</span><span class="s1">&#39;slide&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">incl_loc</span><span class="p">:</span>
                    <span class="n">sig</span><span class="p">[</span><span class="s1">&#39;loc_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                    <span class="n">sig</span><span class="p">[</span><span class="s1">&#39;loc_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">image_sig</span>

            <span class="c1"># Assemble dataset</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_generator</span><span class="p">(</span>
                <span class="n">tile_generator</span><span class="p">,</span>
                <span class="n">output_signature</span><span class="o">=</span><span class="n">sig</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">dataset</span>

    <span class="k">def</span> <span class="nf">torch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">img_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;numpy&#39;</span><span class="p">,</span>
        <span class="n">incl_slidenames</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">incl_loc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">shuffle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">infinite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">to_tensor</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a PyTorch iterator which extractes tiles from this slide.</span>

<span class="sd">        Args:</span>
<span class="sd">            img_format (str, optional): Image format for returned image tiles.</span>
<span class="sd">                Options include &#39;png&#39;, &#39;jpg&#39;, and &#39;numpy&#39;. Defaults to &#39;numpy&#39;.</span>
<span class="sd">            incl_slidenames (bool, optional): Yield slide names for each</span>
<span class="sd">                image tile. Defaults to False.</span>
<span class="sd">            incl_loc (Optional[str], optional): Yield image tile location</span>
<span class="sd">                with each image tile. Options include True, &#39;coord&#39;, or &#39;grid&#39;.</span>
<span class="sd">                If True or &#39;coord&#39;, will return X/Y coordinates of the tile center</span>
<span class="sd">                in the slide&#39;s highest magnification layer. If &#39;grid&#39;, returns</span>
<span class="sd">                the grid indices for the tile. Defaults to None.</span>
<span class="sd">            shuffle (bool, optional): Shuffle image tiles. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An iterator which yields image tiles as Torch tensors.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Iterator[Any]: Items yielded by the Dataset are in dictionary</span>
<span class="sd">            format, with the keys:</span>

<span class="sd">            &#39;image_raw&#39;:    Contains the image as a Tensor (jpg, png, or numpy)</span>
<span class="sd">            &#39;slide&#39;:        Slide name (if ``incl_slidenames=True``)</span>
<span class="sd">            &#39;loc_x&#39;         Image tile center x location (if ``incl_loc`` provided)</span>
<span class="sd">            &#39;loc_y&#39;         Image tile center y location (if ``incl_loc`` provided)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">torch</span>

        <span class="k">def</span> <span class="nf">tile_generator</span><span class="p">():</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">image_dict</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_generator</span><span class="p">(</span>
                    <span class="n">shuffle</span><span class="o">=</span><span class="n">shuffle</span><span class="p">,</span>
                    <span class="n">show_progress</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">img_format</span><span class="o">=</span><span class="n">img_format</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">incl_slidenames</span> <span class="ow">or</span> <span class="n">incl_loc</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">to_tensor</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">to_tensor</span><span class="p">:</span>
                            <span class="n">to_return</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;image_raw&#39;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">])}</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">to_return</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;image_raw&#39;</span><span class="p">:</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;image&#39;</span><span class="p">]}</span>
                        <span class="k">if</span> <span class="n">incl_slidenames</span><span class="p">:</span>
                            <span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;slide&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
                        <span class="k">if</span> <span class="n">incl_loc</span> <span class="o">==</span> <span class="s1">&#39;coord&#39;</span> <span class="ow">or</span> <span class="n">incl_loc</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                            <span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;loc_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;loc_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;loc&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">incl_loc</span> <span class="o">==</span> <span class="s1">&#39;grid&#39;</span><span class="p">:</span>
                            <span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;loc_x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">to_return</span><span class="p">[</span><span class="s1">&#39;loc_y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_dict</span><span class="p">[</span><span class="s1">&#39;grid&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">yield</span> <span class="n">to_return</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">infinite</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">tile_generator</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">verify_alignment</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">slide</span><span class="p">:</span> <span class="s2">&quot;WSI&quot;</span><span class="p">,</span>
        <span class="n">mpp</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Verify alignment to another slide by calculating MSE.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slide</span><span class="p">,</span> <span class="n">WSI</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only align to another slide.&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate thumbnails for alignment.</span>
        <span class="n">our_thumb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">thumb</span><span class="p">(</span><span class="n">mpp</span><span class="o">=</span><span class="n">mpp</span><span class="p">))</span>
        <span class="n">their_thumb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">slide</span><span class="o">.</span><span class="n">thumb</span><span class="p">(</span><span class="n">mpp</span><span class="o">=</span><span class="n">mpp</span><span class="p">))</span>

        <span class="n">aligned_theirs</span> <span class="o">=</span> <span class="n">align_image</span><span class="p">(</span><span class="n">their_thumb</span><span class="p">,</span> <span class="n">our_thumb</span><span class="p">)</span>

        <span class="n">theirs_gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">aligned_theirs</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
        <span class="n">ours_gray</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">our_thumb</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">compute_alignment_mse</span><span class="p">(</span><span class="n">theirs_gray</span><span class="p">,</span> <span class="n">ours_gray</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Open the slide in Slideflow Studio for interactive display.</span>

<span class="sd">        See :ref:`studio` for more information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">slideflow.studio</span> <span class="kn">import</span> <span class="n">Studio</span>

        <span class="n">studio</span> <span class="o">=</span> <span class="n">Studio</span><span class="p">()</span>
        <span class="n">studio</span><span class="o">.</span><span class="n">load_slide</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">studio</span><span class="o">.</span><span class="n">run</span><span class="p">()</span></div>
</pre></div>

             </article>

            </div>
            <footer>




    <hr>



  <div role="contentinfo">
    <p>
        &copy; Copyright 2023, James M Dolezal.

    </p>
  </div>

      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>


</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">

            </div>
          </div>
        </div>
      </section>
    </div>







       <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
         <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
         <script src="../../../../_static/doctools.js"></script>
         <script src="../../../../_static/sphinx_highlight.js"></script>



  <script type="text/javascript" src="../../../../_static/js/vendor/jquery-3.6.3.min.js"></script>
  <script type="text/javascript" src="../../../../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../../../../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  <!-- Begin Footer -->

  <!-- End Footer -->

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://pytorch.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="https://slideflow.dev">Docs</a>
          </li>

          <li>
            <a href="https://slideflow.dev/tutorial1/">Tutorials</a>
          </li>

          <li>
            <a href="https://github.com/slideflow/slideflow">Github</a>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script script type="text/javascript">
    var collapsedSections = [];
  </script>

  <script type="text/javascript" src="../../../../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>